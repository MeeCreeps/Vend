// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_api_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_api_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_api_2eproto;
namespace api {
class Check;
struct CheckDefaultTypeInternal;
extern CheckDefaultTypeInternal _Check_default_instance_;
class Facet;
struct FacetDefaultTypeInternal;
extern FacetDefaultTypeInternal _Facet_default_instance_;
class Jwt;
struct JwtDefaultTypeInternal;
extern JwtDefaultTypeInternal _Jwt_default_instance_;
class Latency;
struct LatencyDefaultTypeInternal;
extern LatencyDefaultTypeInternal _Latency_default_instance_;
class ListOfString;
struct ListOfStringDefaultTypeInternal;
extern ListOfStringDefaultTypeInternal _ListOfString_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class Metrics;
struct MetricsDefaultTypeInternal;
extern MetricsDefaultTypeInternal _Metrics_default_instance_;
class Metrics_NumUidsEntry_DoNotUse;
struct Metrics_NumUidsEntry_DoNotUseDefaultTypeInternal;
extern Metrics_NumUidsEntry_DoNotUseDefaultTypeInternal _Metrics_NumUidsEntry_DoNotUse_default_instance_;
class Mutation;
struct MutationDefaultTypeInternal;
extern MutationDefaultTypeInternal _Mutation_default_instance_;
class NQuad;
struct NQuadDefaultTypeInternal;
extern NQuadDefaultTypeInternal _NQuad_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Request_VarsEntry_DoNotUse;
struct Request_VarsEntry_DoNotUseDefaultTypeInternal;
extern Request_VarsEntry_DoNotUseDefaultTypeInternal _Request_VarsEntry_DoNotUse_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_HdrsEntry_DoNotUse;
struct Response_HdrsEntry_DoNotUseDefaultTypeInternal;
extern Response_HdrsEntry_DoNotUseDefaultTypeInternal _Response_HdrsEntry_DoNotUse_default_instance_;
class Response_UidsEntry_DoNotUse;
struct Response_UidsEntry_DoNotUseDefaultTypeInternal;
extern Response_UidsEntry_DoNotUseDefaultTypeInternal _Response_UidsEntry_DoNotUse_default_instance_;
class TxnContext;
struct TxnContextDefaultTypeInternal;
extern TxnContextDefaultTypeInternal _TxnContext_default_instance_;
class Uids;
struct UidsDefaultTypeInternal;
extern UidsDefaultTypeInternal _Uids_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace api
PROTOBUF_NAMESPACE_OPEN
template<> ::api::Check* Arena::CreateMaybeMessage<::api::Check>(Arena*);
template<> ::api::Facet* Arena::CreateMaybeMessage<::api::Facet>(Arena*);
template<> ::api::Jwt* Arena::CreateMaybeMessage<::api::Jwt>(Arena*);
template<> ::api::Latency* Arena::CreateMaybeMessage<::api::Latency>(Arena*);
template<> ::api::ListOfString* Arena::CreateMaybeMessage<::api::ListOfString>(Arena*);
template<> ::api::LoginRequest* Arena::CreateMaybeMessage<::api::LoginRequest>(Arena*);
template<> ::api::Metrics* Arena::CreateMaybeMessage<::api::Metrics>(Arena*);
template<> ::api::Metrics_NumUidsEntry_DoNotUse* Arena::CreateMaybeMessage<::api::Metrics_NumUidsEntry_DoNotUse>(Arena*);
template<> ::api::Mutation* Arena::CreateMaybeMessage<::api::Mutation>(Arena*);
template<> ::api::NQuad* Arena::CreateMaybeMessage<::api::NQuad>(Arena*);
template<> ::api::Operation* Arena::CreateMaybeMessage<::api::Operation>(Arena*);
template<> ::api::Payload* Arena::CreateMaybeMessage<::api::Payload>(Arena*);
template<> ::api::Request* Arena::CreateMaybeMessage<::api::Request>(Arena*);
template<> ::api::Request_VarsEntry_DoNotUse* Arena::CreateMaybeMessage<::api::Request_VarsEntry_DoNotUse>(Arena*);
template<> ::api::Response* Arena::CreateMaybeMessage<::api::Response>(Arena*);
template<> ::api::Response_HdrsEntry_DoNotUse* Arena::CreateMaybeMessage<::api::Response_HdrsEntry_DoNotUse>(Arena*);
template<> ::api::Response_UidsEntry_DoNotUse* Arena::CreateMaybeMessage<::api::Response_UidsEntry_DoNotUse>(Arena*);
template<> ::api::TxnContext* Arena::CreateMaybeMessage<::api::TxnContext>(Arena*);
template<> ::api::Uids* Arena::CreateMaybeMessage<::api::Uids>(Arena*);
template<> ::api::Value* Arena::CreateMaybeMessage<::api::Value>(Arena*);
template<> ::api::Version* Arena::CreateMaybeMessage<::api::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace api {

enum Request_RespFormat : int {
  Request_RespFormat_JSON = 0,
  Request_RespFormat_RDF = 1,
  Request_RespFormat_Request_RespFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Request_RespFormat_Request_RespFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Request_RespFormat_IsValid(int value);
constexpr Request_RespFormat Request_RespFormat_RespFormat_MIN = Request_RespFormat_JSON;
constexpr Request_RespFormat Request_RespFormat_RespFormat_MAX = Request_RespFormat_RDF;
constexpr int Request_RespFormat_RespFormat_ARRAYSIZE = Request_RespFormat_RespFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_RespFormat_descriptor();
template<typename T>
inline const std::string& Request_RespFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_RespFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_RespFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_RespFormat_descriptor(), enum_t_value);
}
inline bool Request_RespFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_RespFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_RespFormat>(
    Request_RespFormat_descriptor(), name, value);
}
enum Operation_DropOp : int {
  Operation_DropOp_NONE = 0,
  Operation_DropOp_ALL = 1,
  Operation_DropOp_DATA = 2,
  Operation_DropOp_ATTR = 3,
  Operation_DropOp_TYPE = 4,
  Operation_DropOp_Operation_DropOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Operation_DropOp_Operation_DropOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Operation_DropOp_IsValid(int value);
constexpr Operation_DropOp Operation_DropOp_DropOp_MIN = Operation_DropOp_NONE;
constexpr Operation_DropOp Operation_DropOp_DropOp_MAX = Operation_DropOp_TYPE;
constexpr int Operation_DropOp_DropOp_ARRAYSIZE = Operation_DropOp_DropOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operation_DropOp_descriptor();
template<typename T>
inline const std::string& Operation_DropOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Operation_DropOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Operation_DropOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Operation_DropOp_descriptor(), enum_t_value);
}
inline bool Operation_DropOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation_DropOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Operation_DropOp>(
    Operation_DropOp_descriptor(), name, value);
}
enum Facet_ValType : int {
  Facet_ValType_STRING = 0,
  Facet_ValType_INT = 1,
  Facet_ValType_FLOAT = 2,
  Facet_ValType_BOOL = 3,
  Facet_ValType_DATETIME = 4,
  Facet_ValType_Facet_ValType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Facet_ValType_Facet_ValType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Facet_ValType_IsValid(int value);
constexpr Facet_ValType Facet_ValType_ValType_MIN = Facet_ValType_STRING;
constexpr Facet_ValType Facet_ValType_ValType_MAX = Facet_ValType_DATETIME;
constexpr int Facet_ValType_ValType_ARRAYSIZE = Facet_ValType_ValType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Facet_ValType_descriptor();
template<typename T>
inline const std::string& Facet_ValType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Facet_ValType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Facet_ValType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Facet_ValType_descriptor(), enum_t_value);
}
inline bool Facet_ValType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Facet_ValType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Facet_ValType>(
    Facet_ValType_descriptor(), name, value);
}
// ===================================================================

class Request_VarsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Request_VarsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Request_VarsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Request_VarsEntry_DoNotUse();
  explicit constexpr Request_VarsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Request_VarsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Request_VarsEntry_DoNotUse& other);
  static const Request_VarsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Request_VarsEntry_DoNotUse*>(&_Request_VarsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Request.VarsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Request.VarsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Request_RespFormat RespFormat;
  static constexpr RespFormat JSON =
    Request_RespFormat_JSON;
  static constexpr RespFormat RDF =
    Request_RespFormat_RDF;
  static inline bool RespFormat_IsValid(int value) {
    return Request_RespFormat_IsValid(value);
  }
  static constexpr RespFormat RespFormat_MIN =
    Request_RespFormat_RespFormat_MIN;
  static constexpr RespFormat RespFormat_MAX =
    Request_RespFormat_RespFormat_MAX;
  static constexpr int RespFormat_ARRAYSIZE =
    Request_RespFormat_RespFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RespFormat_descriptor() {
    return Request_RespFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& RespFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RespFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RespFormat_Name.");
    return Request_RespFormat_Name(enum_t_value);
  }
  static inline bool RespFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RespFormat* value) {
    return Request_RespFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVarsFieldNumber = 5,
    kMutationsFieldNumber = 12,
    kQueryFieldNumber = 4,
    kHashFieldNumber = 15,
    kStartTsFieldNumber = 1,
    kReadOnlyFieldNumber = 6,
    kBestEffortFieldNumber = 7,
    kCommitNowFieldNumber = 13,
    kRespFormatFieldNumber = 14,
  };
  // map<string, string> vars = 5;
  int vars_size() const;
  private:
  int _internal_vars_size() const;
  public:
  void clear_vars();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vars() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vars();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vars() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vars();

  // repeated .api.Mutation mutations = 12;
  int mutations_size() const;
  private:
  int _internal_mutations_size() const;
  public:
  void clear_mutations();
  ::api::Mutation* mutable_mutations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Mutation >*
      mutable_mutations();
  private:
  const ::api::Mutation& _internal_mutations(int index) const;
  ::api::Mutation* _internal_add_mutations();
  public:
  const ::api::Mutation& mutations(int index) const;
  ::api::Mutation* add_mutations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Mutation >&
      mutations() const;

  // string query = 4;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // string hash = 15;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint64 start_ts = 1;
  void clear_start_ts();
  uint64_t start_ts() const;
  void set_start_ts(uint64_t value);
  private:
  uint64_t _internal_start_ts() const;
  void _internal_set_start_ts(uint64_t value);
  public:

  // bool read_only = 6;
  void clear_read_only();
  bool read_only() const;
  void set_read_only(bool value);
  private:
  bool _internal_read_only() const;
  void _internal_set_read_only(bool value);
  public:

  // bool best_effort = 7;
  void clear_best_effort();
  bool best_effort() const;
  void set_best_effort(bool value);
  private:
  bool _internal_best_effort() const;
  void _internal_set_best_effort(bool value);
  public:

  // bool commit_now = 13;
  void clear_commit_now();
  bool commit_now() const;
  void set_commit_now(bool value);
  private:
  bool _internal_commit_now() const;
  void _internal_set_commit_now(bool value);
  public:

  // .api.Request.RespFormat resp_format = 14;
  void clear_resp_format();
  ::api::Request_RespFormat resp_format() const;
  void set_resp_format(::api::Request_RespFormat value);
  private:
  ::api::Request_RespFormat _internal_resp_format() const;
  void _internal_set_resp_format(::api::Request_RespFormat value);
  public:

  // @@protoc_insertion_point(class_scope:api.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Request_VarsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> vars_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Mutation > mutations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  uint64_t start_ts_;
  bool read_only_;
  bool best_effort_;
  bool commit_now_;
  int resp_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Uids final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Uids) */ {
 public:
  inline Uids() : Uids(nullptr) {}
  ~Uids() override;
  explicit constexpr Uids(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uids(const Uids& from);
  Uids(Uids&& from) noexcept
    : Uids() {
    *this = ::std::move(from);
  }

  inline Uids& operator=(const Uids& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uids& operator=(Uids&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uids& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uids* internal_default_instance() {
    return reinterpret_cast<const Uids*>(
               &_Uids_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Uids& a, Uids& b) {
    a.Swap(&b);
  }
  inline void Swap(Uids* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uids* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uids* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uids>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uids& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uids& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uids* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Uids";
  }
  protected:
  explicit Uids(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidsFieldNumber = 1,
  };
  // repeated string uids = 1;
  int uids_size() const;
  private:
  int _internal_uids_size() const;
  public:
  void clear_uids();
  const std::string& uids(int index) const;
  std::string* mutable_uids(int index);
  void set_uids(int index, const std::string& value);
  void set_uids(int index, std::string&& value);
  void set_uids(int index, const char* value);
  void set_uids(int index, const char* value, size_t size);
  std::string* add_uids();
  void add_uids(const std::string& value);
  void add_uids(std::string&& value);
  void add_uids(const char* value);
  void add_uids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uids();
  private:
  const std::string& _internal_uids(int index) const;
  std::string* _internal_add_uids();
  public:

  // @@protoc_insertion_point(class_scope:api.Uids)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class ListOfString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.ListOfString) */ {
 public:
  inline ListOfString() : ListOfString(nullptr) {}
  ~ListOfString() override;
  explicit constexpr ListOfString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOfString(const ListOfString& from);
  ListOfString(ListOfString&& from) noexcept
    : ListOfString() {
    *this = ::std::move(from);
  }

  inline ListOfString& operator=(const ListOfString& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOfString& operator=(ListOfString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOfString& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOfString* internal_default_instance() {
    return reinterpret_cast<const ListOfString*>(
               &_ListOfString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListOfString& a, ListOfString& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOfString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOfString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOfString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOfString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOfString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListOfString& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOfString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.ListOfString";
  }
  protected:
  explicit ListOfString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:api.ListOfString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Response_UidsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_UidsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_UidsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Response_UidsEntry_DoNotUse();
  explicit constexpr Response_UidsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_UidsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_UidsEntry_DoNotUse& other);
  static const Response_UidsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_UidsEntry_DoNotUse*>(&_Response_UidsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Response.UidsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Response.UidsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Response_HdrsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_HdrsEntry_DoNotUse, 
    std::string, ::api::ListOfString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_HdrsEntry_DoNotUse, 
    std::string, ::api::ListOfString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Response_HdrsEntry_DoNotUse();
  explicit constexpr Response_HdrsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_HdrsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_HdrsEntry_DoNotUse& other);
  static const Response_HdrsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_HdrsEntry_DoNotUse*>(&_Response_HdrsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Response.HdrsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUidsFieldNumber = 12,
    kHdrsFieldNumber = 14,
    kJsonFieldNumber = 1,
    kRdfFieldNumber = 13,
    kTxnFieldNumber = 2,
    kLatencyFieldNumber = 3,
    kMetricsFieldNumber = 4,
  };
  // map<string, string> uids = 12;
  int uids_size() const;
  private:
  int _internal_uids_size() const;
  public:
  void clear_uids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_uids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_uids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      uids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_uids();

  // map<string, .api.ListOfString> hdrs = 14;
  int hdrs_size() const;
  private:
  int _internal_hdrs_size() const;
  public:
  void clear_hdrs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >&
      _internal_hdrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >*
      _internal_mutable_hdrs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >&
      hdrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >*
      mutable_hdrs();

  // bytes json = 1;
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // bytes rdf = 13;
  void clear_rdf();
  const std::string& rdf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rdf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rdf();
  PROTOBUF_NODISCARD std::string* release_rdf();
  void set_allocated_rdf(std::string* rdf);
  private:
  const std::string& _internal_rdf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rdf(const std::string& value);
  std::string* _internal_mutable_rdf();
  public:

  // .api.TxnContext txn = 2;
  bool has_txn() const;
  private:
  bool _internal_has_txn() const;
  public:
  void clear_txn();
  const ::api::TxnContext& txn() const;
  PROTOBUF_NODISCARD ::api::TxnContext* release_txn();
  ::api::TxnContext* mutable_txn();
  void set_allocated_txn(::api::TxnContext* txn);
  private:
  const ::api::TxnContext& _internal_txn() const;
  ::api::TxnContext* _internal_mutable_txn();
  public:
  void unsafe_arena_set_allocated_txn(
      ::api::TxnContext* txn);
  ::api::TxnContext* unsafe_arena_release_txn();

  // .api.Latency latency = 3;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  const ::api::Latency& latency() const;
  PROTOBUF_NODISCARD ::api::Latency* release_latency();
  ::api::Latency* mutable_latency();
  void set_allocated_latency(::api::Latency* latency);
  private:
  const ::api::Latency& _internal_latency() const;
  ::api::Latency* _internal_mutable_latency();
  public:
  void unsafe_arena_set_allocated_latency(
      ::api::Latency* latency);
  ::api::Latency* unsafe_arena_release_latency();

  // .api.Metrics metrics = 4;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::api::Metrics& metrics() const;
  PROTOBUF_NODISCARD ::api::Metrics* release_metrics();
  ::api::Metrics* mutable_metrics();
  void set_allocated_metrics(::api::Metrics* metrics);
  private:
  const ::api::Metrics& _internal_metrics() const;
  ::api::Metrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::api::Metrics* metrics);
  ::api::Metrics* unsafe_arena_release_metrics();

  // @@protoc_insertion_point(class_scope:api.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Response_UidsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> uids_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Response_HdrsEntry_DoNotUse,
      std::string, ::api::ListOfString,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> hdrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rdf_;
  ::api::TxnContext* txn_;
  ::api::Latency* latency_;
  ::api::Metrics* metrics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Mutation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Mutation) */ {
 public:
  inline Mutation() : Mutation(nullptr) {}
  ~Mutation() override;
  explicit constexpr Mutation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mutation(const Mutation& from);
  Mutation(Mutation&& from) noexcept
    : Mutation() {
    *this = ::std::move(from);
  }

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mutation& operator=(Mutation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mutation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mutation* internal_default_instance() {
    return reinterpret_cast<const Mutation*>(
               &_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Mutation& a, Mutation& b) {
    a.Swap(&b);
  }
  inline void Swap(Mutation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mutation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mutation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Mutation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Mutation";
  }
  protected:
  explicit Mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetFieldNumber = 5,
    kDelFieldNumber = 6,
    kSetJsonFieldNumber = 1,
    kDeleteJsonFieldNumber = 2,
    kSetNquadsFieldNumber = 3,
    kDelNquadsFieldNumber = 4,
    kCondFieldNumber = 9,
    kCommitNowFieldNumber = 14,
  };
  // repeated .api.NQuad set = 5;
  int set_size() const;
  private:
  int _internal_set_size() const;
  public:
  void clear_set();
  ::api::NQuad* mutable_set(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >*
      mutable_set();
  private:
  const ::api::NQuad& _internal_set(int index) const;
  ::api::NQuad* _internal_add_set();
  public:
  const ::api::NQuad& set(int index) const;
  ::api::NQuad* add_set();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >&
      set() const;

  // repeated .api.NQuad del = 6;
  int del_size() const;
  private:
  int _internal_del_size() const;
  public:
  void clear_del();
  ::api::NQuad* mutable_del(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >*
      mutable_del();
  private:
  const ::api::NQuad& _internal_del(int index) const;
  ::api::NQuad* _internal_add_del();
  public:
  const ::api::NQuad& del(int index) const;
  ::api::NQuad* add_del();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >&
      del() const;

  // bytes set_json = 1;
  void clear_set_json();
  const std::string& set_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_json();
  PROTOBUF_NODISCARD std::string* release_set_json();
  void set_allocated_set_json(std::string* set_json);
  private:
  const std::string& _internal_set_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_json(const std::string& value);
  std::string* _internal_mutable_set_json();
  public:

  // bytes delete_json = 2;
  void clear_delete_json();
  const std::string& delete_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delete_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delete_json();
  PROTOBUF_NODISCARD std::string* release_delete_json();
  void set_allocated_delete_json(std::string* delete_json);
  private:
  const std::string& _internal_delete_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delete_json(const std::string& value);
  std::string* _internal_mutable_delete_json();
  public:

  // bytes set_nquads = 3;
  void clear_set_nquads();
  const std::string& set_nquads() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_nquads(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_nquads();
  PROTOBUF_NODISCARD std::string* release_set_nquads();
  void set_allocated_set_nquads(std::string* set_nquads);
  private:
  const std::string& _internal_set_nquads() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_nquads(const std::string& value);
  std::string* _internal_mutable_set_nquads();
  public:

  // bytes del_nquads = 4;
  void clear_del_nquads();
  const std::string& del_nquads() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_del_nquads(ArgT0&& arg0, ArgT... args);
  std::string* mutable_del_nquads();
  PROTOBUF_NODISCARD std::string* release_del_nquads();
  void set_allocated_del_nquads(std::string* del_nquads);
  private:
  const std::string& _internal_del_nquads() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_del_nquads(const std::string& value);
  std::string* _internal_mutable_del_nquads();
  public:

  // string cond = 9;
  void clear_cond();
  const std::string& cond() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cond(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cond();
  PROTOBUF_NODISCARD std::string* release_cond();
  void set_allocated_cond(std::string* cond);
  private:
  const std::string& _internal_cond() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cond(const std::string& value);
  std::string* _internal_mutable_cond();
  public:

  // bool commit_now = 14;
  void clear_commit_now();
  bool commit_now() const;
  void set_commit_now(bool value);
  private:
  bool _internal_commit_now() const;
  void _internal_set_commit_now(bool value);
  public:

  // @@protoc_insertion_point(class_scope:api.Mutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad > set_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad > del_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_json_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delete_json_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_nquads_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr del_nquads_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cond_;
  bool commit_now_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit constexpr Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Operation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Operation_DropOp DropOp;
  static constexpr DropOp NONE =
    Operation_DropOp_NONE;
  static constexpr DropOp ALL =
    Operation_DropOp_ALL;
  static constexpr DropOp DATA =
    Operation_DropOp_DATA;
  static constexpr DropOp ATTR =
    Operation_DropOp_ATTR;
  static constexpr DropOp TYPE =
    Operation_DropOp_TYPE;
  static inline bool DropOp_IsValid(int value) {
    return Operation_DropOp_IsValid(value);
  }
  static constexpr DropOp DropOp_MIN =
    Operation_DropOp_DropOp_MIN;
  static constexpr DropOp DropOp_MAX =
    Operation_DropOp_DropOp_MAX;
  static constexpr int DropOp_ARRAYSIZE =
    Operation_DropOp_DropOp_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DropOp_descriptor() {
    return Operation_DropOp_descriptor();
  }
  template<typename T>
  static inline const std::string& DropOp_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DropOp>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DropOp_Name.");
    return Operation_DropOp_Name(enum_t_value);
  }
  static inline bool DropOp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DropOp* value) {
    return Operation_DropOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
    kDropAttrFieldNumber = 2,
    kDropValueFieldNumber = 5,
    kDropOpFieldNumber = 4,
    kDropAllFieldNumber = 3,
    kRunInBackgroundFieldNumber = 6,
  };
  // string schema = 1;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // string drop_attr = 2;
  void clear_drop_attr();
  const std::string& drop_attr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_drop_attr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_drop_attr();
  PROTOBUF_NODISCARD std::string* release_drop_attr();
  void set_allocated_drop_attr(std::string* drop_attr);
  private:
  const std::string& _internal_drop_attr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drop_attr(const std::string& value);
  std::string* _internal_mutable_drop_attr();
  public:

  // string drop_value = 5;
  void clear_drop_value();
  const std::string& drop_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_drop_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_drop_value();
  PROTOBUF_NODISCARD std::string* release_drop_value();
  void set_allocated_drop_value(std::string* drop_value);
  private:
  const std::string& _internal_drop_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drop_value(const std::string& value);
  std::string* _internal_mutable_drop_value();
  public:

  // .api.Operation.DropOp drop_op = 4;
  void clear_drop_op();
  ::api::Operation_DropOp drop_op() const;
  void set_drop_op(::api::Operation_DropOp value);
  private:
  ::api::Operation_DropOp _internal_drop_op() const;
  void _internal_set_drop_op(::api::Operation_DropOp value);
  public:

  // bool drop_all = 3;
  void clear_drop_all();
  bool drop_all() const;
  void set_drop_all(bool value);
  private:
  bool _internal_drop_all() const;
  void _internal_set_drop_all(bool value);
  public:

  // bool run_in_background = 6;
  void clear_run_in_background();
  bool run_in_background() const;
  void set_run_in_background(bool value);
  private:
  bool _internal_run_in_background() const;
  void _internal_set_run_in_background(bool value);
  public:

  // @@protoc_insertion_point(class_scope:api.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr drop_attr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr drop_value_;
  int drop_op_;
  bool drop_all_;
  bool run_in_background_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit constexpr Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Payload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes Data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:api.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class TxnContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.TxnContext) */ {
 public:
  inline TxnContext() : TxnContext(nullptr) {}
  ~TxnContext() override;
  explicit constexpr TxnContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnContext(const TxnContext& from);
  TxnContext(TxnContext&& from) noexcept
    : TxnContext() {
    *this = ::std::move(from);
  }

  inline TxnContext& operator=(const TxnContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnContext& operator=(TxnContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnContext* internal_default_instance() {
    return reinterpret_cast<const TxnContext*>(
               &_TxnContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TxnContext& a, TxnContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxnContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.TxnContext";
  }
  protected:
  explicit TxnContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 4,
    kPredsFieldNumber = 5,
    kHashFieldNumber = 6,
    kStartTsFieldNumber = 1,
    kCommitTsFieldNumber = 2,
    kAbortedFieldNumber = 3,
  };
  // repeated string keys = 4;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated string preds = 5;
  int preds_size() const;
  private:
  int _internal_preds_size() const;
  public:
  void clear_preds();
  const std::string& preds(int index) const;
  std::string* mutable_preds(int index);
  void set_preds(int index, const std::string& value);
  void set_preds(int index, std::string&& value);
  void set_preds(int index, const char* value);
  void set_preds(int index, const char* value, size_t size);
  std::string* add_preds();
  void add_preds(const std::string& value);
  void add_preds(std::string&& value);
  void add_preds(const char* value);
  void add_preds(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& preds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_preds();
  private:
  const std::string& _internal_preds(int index) const;
  std::string* _internal_add_preds();
  public:

  // string hash = 6;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint64 start_ts = 1;
  void clear_start_ts();
  uint64_t start_ts() const;
  void set_start_ts(uint64_t value);
  private:
  uint64_t _internal_start_ts() const;
  void _internal_set_start_ts(uint64_t value);
  public:

  // uint64 commit_ts = 2;
  void clear_commit_ts();
  uint64_t commit_ts() const;
  void set_commit_ts(uint64_t value);
  private:
  uint64_t _internal_commit_ts() const;
  void _internal_set_commit_ts(uint64_t value);
  public:

  // bool aborted = 3;
  void clear_aborted();
  bool aborted() const;
  void set_aborted(bool value);
  private:
  bool _internal_aborted() const;
  void _internal_set_aborted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:api.TxnContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> preds_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  uint64_t start_ts_;
  uint64_t commit_ts_;
  bool aborted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Check final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:api.Check) */ {
 public:
  inline Check() : Check(nullptr) {}
  explicit constexpr Check(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Check(const Check& from);
  Check(Check&& from) noexcept
    : Check() {
    *this = ::std::move(from);
  }

  inline Check& operator=(const Check& from) {
    CopyFrom(from);
    return *this;
  }
  inline Check& operator=(Check&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Check& default_instance() {
    return *internal_default_instance();
  }
  static inline const Check* internal_default_instance() {
    return reinterpret_cast<const Check*>(
               &_Check_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Check& a, Check& b) {
    a.Swap(&b);
  }
  inline void Swap(Check* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Check* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Check* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Check>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Check& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Check& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Check";
  }
  protected:
  explicit Check(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:api.Check)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit constexpr Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Version& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // string tag = 1;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:api.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Latency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Latency) */ {
 public:
  inline Latency() : Latency(nullptr) {}
  ~Latency() override;
  explicit constexpr Latency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Latency(const Latency& from);
  Latency(Latency&& from) noexcept
    : Latency() {
    *this = ::std::move(from);
  }

  inline Latency& operator=(const Latency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Latency& operator=(Latency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Latency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Latency* internal_default_instance() {
    return reinterpret_cast<const Latency*>(
               &_Latency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Latency& a, Latency& b) {
    a.Swap(&b);
  }
  inline void Swap(Latency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Latency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Latency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Latency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Latency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Latency& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Latency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Latency";
  }
  protected:
  explicit Latency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParsingNsFieldNumber = 1,
    kProcessingNsFieldNumber = 2,
    kEncodingNsFieldNumber = 3,
    kAssignTimestampNsFieldNumber = 4,
    kTotalNsFieldNumber = 5,
  };
  // uint64 parsing_ns = 1;
  void clear_parsing_ns();
  uint64_t parsing_ns() const;
  void set_parsing_ns(uint64_t value);
  private:
  uint64_t _internal_parsing_ns() const;
  void _internal_set_parsing_ns(uint64_t value);
  public:

  // uint64 processing_ns = 2;
  void clear_processing_ns();
  uint64_t processing_ns() const;
  void set_processing_ns(uint64_t value);
  private:
  uint64_t _internal_processing_ns() const;
  void _internal_set_processing_ns(uint64_t value);
  public:

  // uint64 encoding_ns = 3;
  void clear_encoding_ns();
  uint64_t encoding_ns() const;
  void set_encoding_ns(uint64_t value);
  private:
  uint64_t _internal_encoding_ns() const;
  void _internal_set_encoding_ns(uint64_t value);
  public:

  // uint64 assign_timestamp_ns = 4;
  void clear_assign_timestamp_ns();
  uint64_t assign_timestamp_ns() const;
  void set_assign_timestamp_ns(uint64_t value);
  private:
  uint64_t _internal_assign_timestamp_ns() const;
  void _internal_set_assign_timestamp_ns(uint64_t value);
  public:

  // uint64 total_ns = 5;
  void clear_total_ns();
  uint64_t total_ns() const;
  void set_total_ns(uint64_t value);
  private:
  uint64_t _internal_total_ns() const;
  void _internal_set_total_ns(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:api.Latency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t parsing_ns_;
  uint64_t processing_ns_;
  uint64_t encoding_ns_;
  uint64_t assign_timestamp_ns_;
  uint64_t total_ns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Metrics_NumUidsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metrics_NumUidsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metrics_NumUidsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  Metrics_NumUidsEntry_DoNotUse();
  explicit constexpr Metrics_NumUidsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Metrics_NumUidsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metrics_NumUidsEntry_DoNotUse& other);
  static const Metrics_NumUidsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metrics_NumUidsEntry_DoNotUse*>(&_Metrics_NumUidsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "api.Metrics.NumUidsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Metrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Metrics) */ {
 public:
  inline Metrics() : Metrics(nullptr) {}
  ~Metrics() override;
  explicit constexpr Metrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metrics(const Metrics& from);
  Metrics(Metrics&& from) noexcept
    : Metrics() {
    *this = ::std::move(from);
  }

  inline Metrics& operator=(const Metrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metrics& operator=(Metrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metrics* internal_default_instance() {
    return reinterpret_cast<const Metrics*>(
               &_Metrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Metrics& a, Metrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Metrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Metrics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Metrics";
  }
  protected:
  explicit Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNumUidsFieldNumber = 1,
  };
  // map<string, uint64> num_uids = 1;
  int num_uids_size() const;
  private:
  int _internal_num_uids_size() const;
  public:
  void clear_num_uids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      _internal_num_uids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      _internal_mutable_num_uids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      num_uids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      mutable_num_uids();

  // @@protoc_insertion_point(class_scope:api.Metrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metrics_NumUidsEntry_DoNotUse,
      std::string, uint64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> num_uids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class NQuad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.NQuad) */ {
 public:
  inline NQuad() : NQuad(nullptr) {}
  ~NQuad() override;
  explicit constexpr NQuad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NQuad(const NQuad& from);
  NQuad(NQuad&& from) noexcept
    : NQuad() {
    *this = ::std::move(from);
  }

  inline NQuad& operator=(const NQuad& from) {
    CopyFrom(from);
    return *this;
  }
  inline NQuad& operator=(NQuad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NQuad& default_instance() {
    return *internal_default_instance();
  }
  static inline const NQuad* internal_default_instance() {
    return reinterpret_cast<const NQuad*>(
               &_NQuad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NQuad& a, NQuad& b) {
    a.Swap(&b);
  }
  inline void Swap(NQuad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NQuad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NQuad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NQuad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NQuad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NQuad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NQuad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.NQuad";
  }
  protected:
  explicit NQuad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacetsFieldNumber = 7,
    kSubjectFieldNumber = 1,
    kPredicateFieldNumber = 2,
    kObjectIdFieldNumber = 3,
    kLangFieldNumber = 6,
    kObjectValueFieldNumber = 4,
    kNamespaceFieldNumber = 8,
  };
  // repeated .api.Facet facets = 7;
  int facets_size() const;
  private:
  int _internal_facets_size() const;
  public:
  void clear_facets();
  ::api::Facet* mutable_facets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Facet >*
      mutable_facets();
  private:
  const ::api::Facet& _internal_facets(int index) const;
  ::api::Facet* _internal_add_facets();
  public:
  const ::api::Facet& facets(int index) const;
  ::api::Facet* add_facets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Facet >&
      facets() const;

  // string subject = 1;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string predicate = 2;
  void clear_predicate();
  const std::string& predicate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_predicate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_predicate();
  PROTOBUF_NODISCARD std::string* release_predicate();
  void set_allocated_predicate(std::string* predicate);
  private:
  const std::string& _internal_predicate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_predicate(const std::string& value);
  std::string* _internal_mutable_predicate();
  public:

  // string object_id = 3;
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_NODISCARD std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // string lang = 6;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // .api.Value object_value = 4;
  bool has_object_value() const;
  private:
  bool _internal_has_object_value() const;
  public:
  void clear_object_value();
  const ::api::Value& object_value() const;
  PROTOBUF_NODISCARD ::api::Value* release_object_value();
  ::api::Value* mutable_object_value();
  void set_allocated_object_value(::api::Value* object_value);
  private:
  const ::api::Value& _internal_object_value() const;
  ::api::Value* _internal_mutable_object_value();
  public:
  void unsafe_arena_set_allocated_object_value(
      ::api::Value* object_value);
  ::api::Value* unsafe_arena_release_object_value();

  // uint64 namespace = 8;
  void clear_namespace_();
  uint64_t namespace_() const;
  void set_namespace_(uint64_t value);
  private:
  uint64_t _internal_namespace_() const;
  void _internal_set_namespace_(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:api.NQuad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Facet > facets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predicate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
  ::api::Value* object_value_;
  uint64_t namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit constexpr Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValCase {
    kDefaultVal = 1,
    kBytesVal = 2,
    kIntVal = 3,
    kBoolVal = 4,
    kStrVal = 5,
    kDoubleVal = 6,
    kGeoVal = 7,
    kDateVal = 8,
    kDatetimeVal = 9,
    kPasswordVal = 10,
    kUidVal = 11,
    VAL_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultValFieldNumber = 1,
    kBytesValFieldNumber = 2,
    kIntValFieldNumber = 3,
    kBoolValFieldNumber = 4,
    kStrValFieldNumber = 5,
    kDoubleValFieldNumber = 6,
    kGeoValFieldNumber = 7,
    kDateValFieldNumber = 8,
    kDatetimeValFieldNumber = 9,
    kPasswordValFieldNumber = 10,
    kUidValFieldNumber = 11,
  };
  // string default_val = 1;
  bool has_default_val() const;
  private:
  bool _internal_has_default_val() const;
  public:
  void clear_default_val();
  const std::string& default_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_val();
  PROTOBUF_NODISCARD std::string* release_default_val();
  void set_allocated_default_val(std::string* default_val);
  private:
  const std::string& _internal_default_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_val(const std::string& value);
  std::string* _internal_mutable_default_val();
  public:

  // bytes bytes_val = 2;
  bool has_bytes_val() const;
  private:
  bool _internal_has_bytes_val() const;
  public:
  void clear_bytes_val();
  const std::string& bytes_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes_val();
  PROTOBUF_NODISCARD std::string* release_bytes_val();
  void set_allocated_bytes_val(std::string* bytes_val);
  private:
  const std::string& _internal_bytes_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_val(const std::string& value);
  std::string* _internal_mutable_bytes_val();
  public:

  // int64 int_val = 3;
  bool has_int_val() const;
  private:
  bool _internal_has_int_val() const;
  public:
  void clear_int_val();
  int64_t int_val() const;
  void set_int_val(int64_t value);
  private:
  int64_t _internal_int_val() const;
  void _internal_set_int_val(int64_t value);
  public:

  // bool bool_val = 4;
  bool has_bool_val() const;
  private:
  bool _internal_has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);
  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);
  public:

  // string str_val = 5;
  bool has_str_val() const;
  private:
  bool _internal_has_str_val() const;
  public:
  void clear_str_val();
  const std::string& str_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_val();
  PROTOBUF_NODISCARD std::string* release_str_val();
  void set_allocated_str_val(std::string* str_val);
  private:
  const std::string& _internal_str_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_val(const std::string& value);
  std::string* _internal_mutable_str_val();
  public:

  // double double_val = 6;
  bool has_double_val() const;
  private:
  bool _internal_has_double_val() const;
  public:
  void clear_double_val();
  double double_val() const;
  void set_double_val(double value);
  private:
  double _internal_double_val() const;
  void _internal_set_double_val(double value);
  public:

  // bytes geo_val = 7;
  bool has_geo_val() const;
  private:
  bool _internal_has_geo_val() const;
  public:
  void clear_geo_val();
  const std::string& geo_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_geo_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_geo_val();
  PROTOBUF_NODISCARD std::string* release_geo_val();
  void set_allocated_geo_val(std::string* geo_val);
  private:
  const std::string& _internal_geo_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geo_val(const std::string& value);
  std::string* _internal_mutable_geo_val();
  public:

  // bytes date_val = 8;
  bool has_date_val() const;
  private:
  bool _internal_has_date_val() const;
  public:
  void clear_date_val();
  const std::string& date_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_val();
  PROTOBUF_NODISCARD std::string* release_date_val();
  void set_allocated_date_val(std::string* date_val);
  private:
  const std::string& _internal_date_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_val(const std::string& value);
  std::string* _internal_mutable_date_val();
  public:

  // bytes datetime_val = 9;
  bool has_datetime_val() const;
  private:
  bool _internal_has_datetime_val() const;
  public:
  void clear_datetime_val();
  const std::string& datetime_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datetime_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datetime_val();
  PROTOBUF_NODISCARD std::string* release_datetime_val();
  void set_allocated_datetime_val(std::string* datetime_val);
  private:
  const std::string& _internal_datetime_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datetime_val(const std::string& value);
  std::string* _internal_mutable_datetime_val();
  public:

  // string password_val = 10;
  bool has_password_val() const;
  private:
  bool _internal_has_password_val() const;
  public:
  void clear_password_val();
  const std::string& password_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password_val();
  PROTOBUF_NODISCARD std::string* release_password_val();
  void set_allocated_password_val(std::string* password_val);
  private:
  const std::string& _internal_password_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_val(const std::string& value);
  std::string* _internal_mutable_password_val();
  public:

  // uint64 uid_val = 11;
  bool has_uid_val() const;
  private:
  bool _internal_has_uid_val() const;
  public:
  void clear_uid_val();
  uint64_t uid_val() const;
  void set_uid_val(uint64_t value);
  private:
  uint64_t _internal_uid_val() const;
  void _internal_set_uid_val(uint64_t value);
  public:

  void clear_val();
  ValCase val_case() const;
  // @@protoc_insertion_point(class_scope:api.Value)
 private:
  class _Internal;
  void set_has_default_val();
  void set_has_bytes_val();
  void set_has_int_val();
  void set_has_bool_val();
  void set_has_str_val();
  void set_has_double_val();
  void set_has_geo_val();
  void set_has_date_val();
  void set_has_datetime_val();
  void set_has_password_val();
  void set_has_uid_val();

  inline bool has_val() const;
  inline void clear_has_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValUnion {
    constexpr ValUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_val_;
    int64_t int_val_;
    bool bool_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_val_;
    double double_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr geo_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datetime_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_val_;
    uint64_t uid_val_;
  } val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Facet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Facet) */ {
 public:
  inline Facet() : Facet(nullptr) {}
  ~Facet() override;
  explicit constexpr Facet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Facet(const Facet& from);
  Facet(Facet&& from) noexcept
    : Facet() {
    *this = ::std::move(from);
  }

  inline Facet& operator=(const Facet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Facet& operator=(Facet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Facet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Facet* internal_default_instance() {
    return reinterpret_cast<const Facet*>(
               &_Facet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Facet& a, Facet& b) {
    a.Swap(&b);
  }
  inline void Swap(Facet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Facet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Facet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Facet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Facet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Facet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Facet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Facet";
  }
  protected:
  explicit Facet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Facet_ValType ValType;
  static constexpr ValType STRING =
    Facet_ValType_STRING;
  static constexpr ValType INT =
    Facet_ValType_INT;
  static constexpr ValType FLOAT =
    Facet_ValType_FLOAT;
  static constexpr ValType BOOL =
    Facet_ValType_BOOL;
  static constexpr ValType DATETIME =
    Facet_ValType_DATETIME;
  static inline bool ValType_IsValid(int value) {
    return Facet_ValType_IsValid(value);
  }
  static constexpr ValType ValType_MIN =
    Facet_ValType_ValType_MIN;
  static constexpr ValType ValType_MAX =
    Facet_ValType_ValType_MAX;
  static constexpr int ValType_ARRAYSIZE =
    Facet_ValType_ValType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ValType_descriptor() {
    return Facet_ValType_descriptor();
  }
  template<typename T>
  static inline const std::string& ValType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValType_Name.");
    return Facet_ValType_Name(enum_t_value);
  }
  static inline bool ValType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValType* value) {
    return Facet_ValType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kAliasFieldNumber = 5,
    kValTypeFieldNumber = 3,
  };
  // repeated string tokens = 4;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  const std::string& tokens(int index) const;
  std::string* mutable_tokens(int index);
  void set_tokens(int index, const std::string& value);
  void set_tokens(int index, std::string&& value);
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  std::string* add_tokens();
  void add_tokens(const std::string& value);
  void add_tokens(std::string&& value);
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tokens();
  private:
  const std::string& _internal_tokens(int index) const;
  std::string* _internal_add_tokens();
  public:

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string alias = 5;
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // .api.Facet.ValType val_type = 3;
  void clear_val_type();
  ::api::Facet_ValType val_type() const;
  void set_val_type(::api::Facet_ValType value);
  private:
  ::api::Facet_ValType _internal_val_type() const;
  void _internal_set_val_type(::api::Facet_ValType value);
  public:

  // @@protoc_insertion_point(class_scope:api.Facet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tokens_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
  int val_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
    kNamespaceFieldNumber = 4,
  };
  // string userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string refresh_token = 3;
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // uint64 namespace = 4;
  void clear_namespace_();
  uint64_t namespace_() const;
  void set_namespace_(uint64_t value);
  private:
  uint64_t _internal_namespace_() const;
  void _internal_set_namespace_(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:api.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
  uint64_t namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// -------------------------------------------------------------------

class Jwt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:api.Jwt) */ {
 public:
  inline Jwt() : Jwt(nullptr) {}
  ~Jwt() override;
  explicit constexpr Jwt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Jwt(const Jwt& from);
  Jwt(Jwt&& from) noexcept
    : Jwt() {
    *this = ::std::move(from);
  }

  inline Jwt& operator=(const Jwt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Jwt& operator=(Jwt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Jwt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Jwt* internal_default_instance() {
    return reinterpret_cast<const Jwt*>(
               &_Jwt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Jwt& a, Jwt& b) {
    a.Swap(&b);
  }
  inline void Swap(Jwt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Jwt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Jwt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Jwt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Jwt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Jwt& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Jwt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "api.Jwt";
  }
  protected:
  explicit Jwt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessJwtFieldNumber = 1,
    kRefreshJwtFieldNumber = 2,
  };
  // string access_jwt = 1;
  void clear_access_jwt();
  const std::string& access_jwt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_jwt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_jwt();
  PROTOBUF_NODISCARD std::string* release_access_jwt();
  void set_allocated_access_jwt(std::string* access_jwt);
  private:
  const std::string& _internal_access_jwt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_jwt(const std::string& value);
  std::string* _internal_mutable_access_jwt();
  public:

  // string refresh_jwt = 2;
  void clear_refresh_jwt();
  const std::string& refresh_jwt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_jwt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_jwt();
  PROTOBUF_NODISCARD std::string* release_refresh_jwt();
  void set_allocated_refresh_jwt(std::string* refresh_jwt);
  private:
  const std::string& _internal_refresh_jwt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_jwt(const std::string& value);
  std::string* _internal_mutable_refresh_jwt();
  public:

  // @@protoc_insertion_point(class_scope:api.Jwt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_jwt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_jwt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// uint64 start_ts = 1;
inline void Request::clear_start_ts() {
  start_ts_ = uint64_t{0u};
}
inline uint64_t Request::_internal_start_ts() const {
  return start_ts_;
}
inline uint64_t Request::start_ts() const {
  // @@protoc_insertion_point(field_get:api.Request.start_ts)
  return _internal_start_ts();
}
inline void Request::_internal_set_start_ts(uint64_t value) {
  
  start_ts_ = value;
}
inline void Request::set_start_ts(uint64_t value) {
  _internal_set_start_ts(value);
  // @@protoc_insertion_point(field_set:api.Request.start_ts)
}

// string query = 4;
inline void Request::clear_query() {
  query_.ClearToEmpty();
}
inline const std::string& Request::query() const {
  // @@protoc_insertion_point(field_get:api.Request.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_query(ArgT0&& arg0, ArgT... args) {
 
 query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Request.query)
}
inline std::string* Request::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:api.Request.query)
  return _s;
}
inline const std::string& Request::_internal_query() const {
  return query_.Get();
}
inline void Request::_internal_set_query(const std::string& value) {
  
  query_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_query() {
  
  return query_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_query() {
  // @@protoc_insertion_point(field_release:api.Request.query)
  return query_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  query_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (query_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    query_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Request.query)
}

// map<string, string> vars = 5;
inline int Request::_internal_vars_size() const {
  return vars_.size();
}
inline int Request::vars_size() const {
  return _internal_vars_size();
}
inline void Request::clear_vars() {
  vars_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Request::_internal_vars() const {
  return vars_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Request::vars() const {
  // @@protoc_insertion_point(field_map:api.Request.vars)
  return _internal_vars();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Request::_internal_mutable_vars() {
  return vars_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Request::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_map:api.Request.vars)
  return _internal_mutable_vars();
}

// bool read_only = 6;
inline void Request::clear_read_only() {
  read_only_ = false;
}
inline bool Request::_internal_read_only() const {
  return read_only_;
}
inline bool Request::read_only() const {
  // @@protoc_insertion_point(field_get:api.Request.read_only)
  return _internal_read_only();
}
inline void Request::_internal_set_read_only(bool value) {
  
  read_only_ = value;
}
inline void Request::set_read_only(bool value) {
  _internal_set_read_only(value);
  // @@protoc_insertion_point(field_set:api.Request.read_only)
}

// bool best_effort = 7;
inline void Request::clear_best_effort() {
  best_effort_ = false;
}
inline bool Request::_internal_best_effort() const {
  return best_effort_;
}
inline bool Request::best_effort() const {
  // @@protoc_insertion_point(field_get:api.Request.best_effort)
  return _internal_best_effort();
}
inline void Request::_internal_set_best_effort(bool value) {
  
  best_effort_ = value;
}
inline void Request::set_best_effort(bool value) {
  _internal_set_best_effort(value);
  // @@protoc_insertion_point(field_set:api.Request.best_effort)
}

// repeated .api.Mutation mutations = 12;
inline int Request::_internal_mutations_size() const {
  return mutations_.size();
}
inline int Request::mutations_size() const {
  return _internal_mutations_size();
}
inline void Request::clear_mutations() {
  mutations_.Clear();
}
inline ::api::Mutation* Request::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:api.Request.mutations)
  return mutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Mutation >*
Request::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:api.Request.mutations)
  return &mutations_;
}
inline const ::api::Mutation& Request::_internal_mutations(int index) const {
  return mutations_.Get(index);
}
inline const ::api::Mutation& Request::mutations(int index) const {
  // @@protoc_insertion_point(field_get:api.Request.mutations)
  return _internal_mutations(index);
}
inline ::api::Mutation* Request::_internal_add_mutations() {
  return mutations_.Add();
}
inline ::api::Mutation* Request::add_mutations() {
  ::api::Mutation* _add = _internal_add_mutations();
  // @@protoc_insertion_point(field_add:api.Request.mutations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Mutation >&
Request::mutations() const {
  // @@protoc_insertion_point(field_list:api.Request.mutations)
  return mutations_;
}

// bool commit_now = 13;
inline void Request::clear_commit_now() {
  commit_now_ = false;
}
inline bool Request::_internal_commit_now() const {
  return commit_now_;
}
inline bool Request::commit_now() const {
  // @@protoc_insertion_point(field_get:api.Request.commit_now)
  return _internal_commit_now();
}
inline void Request::_internal_set_commit_now(bool value) {
  
  commit_now_ = value;
}
inline void Request::set_commit_now(bool value) {
  _internal_set_commit_now(value);
  // @@protoc_insertion_point(field_set:api.Request.commit_now)
}

// .api.Request.RespFormat resp_format = 14;
inline void Request::clear_resp_format() {
  resp_format_ = 0;
}
inline ::api::Request_RespFormat Request::_internal_resp_format() const {
  return static_cast< ::api::Request_RespFormat >(resp_format_);
}
inline ::api::Request_RespFormat Request::resp_format() const {
  // @@protoc_insertion_point(field_get:api.Request.resp_format)
  return _internal_resp_format();
}
inline void Request::_internal_set_resp_format(::api::Request_RespFormat value) {
  
  resp_format_ = value;
}
inline void Request::set_resp_format(::api::Request_RespFormat value) {
  _internal_set_resp_format(value);
  // @@protoc_insertion_point(field_set:api.Request.resp_format)
}

// string hash = 15;
inline void Request::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Request::hash() const {
  // @@protoc_insertion_point(field_get:api.Request.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Request.hash)
}
inline std::string* Request::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:api.Request.hash)
  return _s;
}
inline const std::string& Request::_internal_hash() const {
  return hash_.Get();
}
inline void Request::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_hash() {
  // @@protoc_insertion_point(field_release:api.Request.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Request.hash)
}

// -------------------------------------------------------------------

// Uids

// repeated string uids = 1;
inline int Uids::_internal_uids_size() const {
  return uids_.size();
}
inline int Uids::uids_size() const {
  return _internal_uids_size();
}
inline void Uids::clear_uids() {
  uids_.Clear();
}
inline std::string* Uids::add_uids() {
  std::string* _s = _internal_add_uids();
  // @@protoc_insertion_point(field_add_mutable:api.Uids.uids)
  return _s;
}
inline const std::string& Uids::_internal_uids(int index) const {
  return uids_.Get(index);
}
inline const std::string& Uids::uids(int index) const {
  // @@protoc_insertion_point(field_get:api.Uids.uids)
  return _internal_uids(index);
}
inline std::string* Uids::mutable_uids(int index) {
  // @@protoc_insertion_point(field_mutable:api.Uids.uids)
  return uids_.Mutable(index);
}
inline void Uids::set_uids(int index, const std::string& value) {
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api.Uids.uids)
}
inline void Uids::set_uids(int index, std::string&& value) {
  uids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api.Uids.uids)
}
inline void Uids::set_uids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api.Uids.uids)
}
inline void Uids::set_uids(int index, const char* value, size_t size) {
  uids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api.Uids.uids)
}
inline std::string* Uids::_internal_add_uids() {
  return uids_.Add();
}
inline void Uids::add_uids(const std::string& value) {
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api.Uids.uids)
}
inline void Uids::add_uids(std::string&& value) {
  uids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api.Uids.uids)
}
inline void Uids::add_uids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api.Uids.uids)
}
inline void Uids::add_uids(const char* value, size_t size) {
  uids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api.Uids.uids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Uids::uids() const {
  // @@protoc_insertion_point(field_list:api.Uids.uids)
  return uids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Uids::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_list:api.Uids.uids)
  return &uids_;
}

// -------------------------------------------------------------------

// ListOfString

// repeated string value = 1;
inline int ListOfString::_internal_value_size() const {
  return value_.size();
}
inline int ListOfString::value_size() const {
  return _internal_value_size();
}
inline void ListOfString::clear_value() {
  value_.Clear();
}
inline std::string* ListOfString::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:api.ListOfString.value)
  return _s;
}
inline const std::string& ListOfString::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& ListOfString::value(int index) const {
  // @@protoc_insertion_point(field_get:api.ListOfString.value)
  return _internal_value(index);
}
inline std::string* ListOfString::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:api.ListOfString.value)
  return value_.Mutable(index);
}
inline void ListOfString::set_value(int index, const std::string& value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api.ListOfString.value)
}
inline void ListOfString::set_value(int index, std::string&& value) {
  value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api.ListOfString.value)
}
inline void ListOfString::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api.ListOfString.value)
}
inline void ListOfString::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api.ListOfString.value)
}
inline std::string* ListOfString::_internal_add_value() {
  return value_.Add();
}
inline void ListOfString::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api.ListOfString.value)
}
inline void ListOfString::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api.ListOfString.value)
}
inline void ListOfString::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api.ListOfString.value)
}
inline void ListOfString::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api.ListOfString.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListOfString::value() const {
  // @@protoc_insertion_point(field_list:api.ListOfString.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListOfString::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:api.ListOfString.value)
  return &value_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Response

// bytes json = 1;
inline void Response::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& Response::json() const {
  // @@protoc_insertion_point(field_get:api.Response.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_json(ArgT0&& arg0, ArgT... args) {
 
 json_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Response.json)
}
inline std::string* Response::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:api.Response.json)
  return _s;
}
inline const std::string& Response::_internal_json() const {
  return json_.Get();
}
inline void Response::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_json() {
  // @@protoc_insertion_point(field_release:api.Response.json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Response::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Response.json)
}

// .api.TxnContext txn = 2;
inline bool Response::_internal_has_txn() const {
  return this != internal_default_instance() && txn_ != nullptr;
}
inline bool Response::has_txn() const {
  return _internal_has_txn();
}
inline void Response::clear_txn() {
  if (GetArenaForAllocation() == nullptr && txn_ != nullptr) {
    delete txn_;
  }
  txn_ = nullptr;
}
inline const ::api::TxnContext& Response::_internal_txn() const {
  const ::api::TxnContext* p = txn_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::TxnContext&>(
      ::api::_TxnContext_default_instance_);
}
inline const ::api::TxnContext& Response::txn() const {
  // @@protoc_insertion_point(field_get:api.Response.txn)
  return _internal_txn();
}
inline void Response::unsafe_arena_set_allocated_txn(
    ::api::TxnContext* txn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  txn_ = txn;
  if (txn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api.Response.txn)
}
inline ::api::TxnContext* Response::release_txn() {
  
  ::api::TxnContext* temp = txn_;
  txn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api::TxnContext* Response::unsafe_arena_release_txn() {
  // @@protoc_insertion_point(field_release:api.Response.txn)
  
  ::api::TxnContext* temp = txn_;
  txn_ = nullptr;
  return temp;
}
inline ::api::TxnContext* Response::_internal_mutable_txn() {
  
  if (txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::api::TxnContext>(GetArenaForAllocation());
    txn_ = p;
  }
  return txn_;
}
inline ::api::TxnContext* Response::mutable_txn() {
  ::api::TxnContext* _msg = _internal_mutable_txn();
  // @@protoc_insertion_point(field_mutable:api.Response.txn)
  return _msg;
}
inline void Response::set_allocated_txn(::api::TxnContext* txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txn_;
  }
  if (txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::api::TxnContext>::GetOwningArena(txn);
    if (message_arena != submessage_arena) {
      txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:api.Response.txn)
}

// .api.Latency latency = 3;
inline bool Response::_internal_has_latency() const {
  return this != internal_default_instance() && latency_ != nullptr;
}
inline bool Response::has_latency() const {
  return _internal_has_latency();
}
inline void Response::clear_latency() {
  if (GetArenaForAllocation() == nullptr && latency_ != nullptr) {
    delete latency_;
  }
  latency_ = nullptr;
}
inline const ::api::Latency& Response::_internal_latency() const {
  const ::api::Latency* p = latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::Latency&>(
      ::api::_Latency_default_instance_);
}
inline const ::api::Latency& Response::latency() const {
  // @@protoc_insertion_point(field_get:api.Response.latency)
  return _internal_latency();
}
inline void Response::unsafe_arena_set_allocated_latency(
    ::api::Latency* latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_);
  }
  latency_ = latency;
  if (latency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api.Response.latency)
}
inline ::api::Latency* Response::release_latency() {
  
  ::api::Latency* temp = latency_;
  latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api::Latency* Response::unsafe_arena_release_latency() {
  // @@protoc_insertion_point(field_release:api.Response.latency)
  
  ::api::Latency* temp = latency_;
  latency_ = nullptr;
  return temp;
}
inline ::api::Latency* Response::_internal_mutable_latency() {
  
  if (latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::api::Latency>(GetArenaForAllocation());
    latency_ = p;
  }
  return latency_;
}
inline ::api::Latency* Response::mutable_latency() {
  ::api::Latency* _msg = _internal_mutable_latency();
  // @@protoc_insertion_point(field_mutable:api.Response.latency)
  return _msg;
}
inline void Response::set_allocated_latency(::api::Latency* latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete latency_;
  }
  if (latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::api::Latency>::GetOwningArena(latency);
    if (message_arena != submessage_arena) {
      latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latency, submessage_arena);
    }
    
  } else {
    
  }
  latency_ = latency;
  // @@protoc_insertion_point(field_set_allocated:api.Response.latency)
}

// .api.Metrics metrics = 4;
inline bool Response::_internal_has_metrics() const {
  return this != internal_default_instance() && metrics_ != nullptr;
}
inline bool Response::has_metrics() const {
  return _internal_has_metrics();
}
inline void Response::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && metrics_ != nullptr) {
    delete metrics_;
  }
  metrics_ = nullptr;
}
inline const ::api::Metrics& Response::_internal_metrics() const {
  const ::api::Metrics* p = metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::Metrics&>(
      ::api::_Metrics_default_instance_);
}
inline const ::api::Metrics& Response::metrics() const {
  // @@protoc_insertion_point(field_get:api.Response.metrics)
  return _internal_metrics();
}
inline void Response::unsafe_arena_set_allocated_metrics(
    ::api::Metrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metrics_);
  }
  metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api.Response.metrics)
}
inline ::api::Metrics* Response::release_metrics() {
  
  ::api::Metrics* temp = metrics_;
  metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api::Metrics* Response::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:api.Response.metrics)
  
  ::api::Metrics* temp = metrics_;
  metrics_ = nullptr;
  return temp;
}
inline ::api::Metrics* Response::_internal_mutable_metrics() {
  
  if (metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::api::Metrics>(GetArenaForAllocation());
    metrics_ = p;
  }
  return metrics_;
}
inline ::api::Metrics* Response::mutable_metrics() {
  ::api::Metrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:api.Response.metrics)
  return _msg;
}
inline void Response::set_allocated_metrics(::api::Metrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::api::Metrics>::GetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:api.Response.metrics)
}

// map<string, string> uids = 12;
inline int Response::_internal_uids_size() const {
  return uids_.size();
}
inline int Response::uids_size() const {
  return _internal_uids_size();
}
inline void Response::clear_uids() {
  uids_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Response::_internal_uids() const {
  return uids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Response::uids() const {
  // @@protoc_insertion_point(field_map:api.Response.uids)
  return _internal_uids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Response::_internal_mutable_uids() {
  return uids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Response::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_map:api.Response.uids)
  return _internal_mutable_uids();
}

// bytes rdf = 13;
inline void Response::clear_rdf() {
  rdf_.ClearToEmpty();
}
inline const std::string& Response::rdf() const {
  // @@protoc_insertion_point(field_get:api.Response.rdf)
  return _internal_rdf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_rdf(ArgT0&& arg0, ArgT... args) {
 
 rdf_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Response.rdf)
}
inline std::string* Response::mutable_rdf() {
  std::string* _s = _internal_mutable_rdf();
  // @@protoc_insertion_point(field_mutable:api.Response.rdf)
  return _s;
}
inline const std::string& Response::_internal_rdf() const {
  return rdf_.Get();
}
inline void Response::_internal_set_rdf(const std::string& value) {
  
  rdf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_rdf() {
  
  return rdf_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_rdf() {
  // @@protoc_insertion_point(field_release:api.Response.rdf)
  return rdf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Response::set_allocated_rdf(std::string* rdf) {
  if (rdf != nullptr) {
    
  } else {
    
  }
  rdf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rdf,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rdf_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rdf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Response.rdf)
}

// map<string, .api.ListOfString> hdrs = 14;
inline int Response::_internal_hdrs_size() const {
  return hdrs_.size();
}
inline int Response::hdrs_size() const {
  return _internal_hdrs_size();
}
inline void Response::clear_hdrs() {
  hdrs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >&
Response::_internal_hdrs() const {
  return hdrs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >&
Response::hdrs() const {
  // @@protoc_insertion_point(field_map:api.Response.hdrs)
  return _internal_hdrs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >*
Response::_internal_mutable_hdrs() {
  return hdrs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::api::ListOfString >*
Response::mutable_hdrs() {
  // @@protoc_insertion_point(field_mutable_map:api.Response.hdrs)
  return _internal_mutable_hdrs();
}

// -------------------------------------------------------------------

// Mutation

// bytes set_json = 1;
inline void Mutation::clear_set_json() {
  set_json_.ClearToEmpty();
}
inline const std::string& Mutation::set_json() const {
  // @@protoc_insertion_point(field_get:api.Mutation.set_json)
  return _internal_set_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutation::set_set_json(ArgT0&& arg0, ArgT... args) {
 
 set_json_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Mutation.set_json)
}
inline std::string* Mutation::mutable_set_json() {
  std::string* _s = _internal_mutable_set_json();
  // @@protoc_insertion_point(field_mutable:api.Mutation.set_json)
  return _s;
}
inline const std::string& Mutation::_internal_set_json() const {
  return set_json_.Get();
}
inline void Mutation::_internal_set_set_json(const std::string& value) {
  
  set_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mutation::_internal_mutable_set_json() {
  
  return set_json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mutation::release_set_json() {
  // @@protoc_insertion_point(field_release:api.Mutation.set_json)
  return set_json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mutation::set_allocated_set_json(std::string* set_json) {
  if (set_json != nullptr) {
    
  } else {
    
  }
  set_json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Mutation.set_json)
}

// bytes delete_json = 2;
inline void Mutation::clear_delete_json() {
  delete_json_.ClearToEmpty();
}
inline const std::string& Mutation::delete_json() const {
  // @@protoc_insertion_point(field_get:api.Mutation.delete_json)
  return _internal_delete_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutation::set_delete_json(ArgT0&& arg0, ArgT... args) {
 
 delete_json_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Mutation.delete_json)
}
inline std::string* Mutation::mutable_delete_json() {
  std::string* _s = _internal_mutable_delete_json();
  // @@protoc_insertion_point(field_mutable:api.Mutation.delete_json)
  return _s;
}
inline const std::string& Mutation::_internal_delete_json() const {
  return delete_json_.Get();
}
inline void Mutation::_internal_set_delete_json(const std::string& value) {
  
  delete_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mutation::_internal_mutable_delete_json() {
  
  return delete_json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mutation::release_delete_json() {
  // @@protoc_insertion_point(field_release:api.Mutation.delete_json)
  return delete_json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mutation::set_allocated_delete_json(std::string* delete_json) {
  if (delete_json != nullptr) {
    
  } else {
    
  }
  delete_json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), delete_json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (delete_json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    delete_json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Mutation.delete_json)
}

// bytes set_nquads = 3;
inline void Mutation::clear_set_nquads() {
  set_nquads_.ClearToEmpty();
}
inline const std::string& Mutation::set_nquads() const {
  // @@protoc_insertion_point(field_get:api.Mutation.set_nquads)
  return _internal_set_nquads();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutation::set_set_nquads(ArgT0&& arg0, ArgT... args) {
 
 set_nquads_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Mutation.set_nquads)
}
inline std::string* Mutation::mutable_set_nquads() {
  std::string* _s = _internal_mutable_set_nquads();
  // @@protoc_insertion_point(field_mutable:api.Mutation.set_nquads)
  return _s;
}
inline const std::string& Mutation::_internal_set_nquads() const {
  return set_nquads_.Get();
}
inline void Mutation::_internal_set_set_nquads(const std::string& value) {
  
  set_nquads_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mutation::_internal_mutable_set_nquads() {
  
  return set_nquads_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mutation::release_set_nquads() {
  // @@protoc_insertion_point(field_release:api.Mutation.set_nquads)
  return set_nquads_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mutation::set_allocated_set_nquads(std::string* set_nquads) {
  if (set_nquads != nullptr) {
    
  } else {
    
  }
  set_nquads_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_nquads,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_nquads_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_nquads_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Mutation.set_nquads)
}

// bytes del_nquads = 4;
inline void Mutation::clear_del_nquads() {
  del_nquads_.ClearToEmpty();
}
inline const std::string& Mutation::del_nquads() const {
  // @@protoc_insertion_point(field_get:api.Mutation.del_nquads)
  return _internal_del_nquads();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutation::set_del_nquads(ArgT0&& arg0, ArgT... args) {
 
 del_nquads_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Mutation.del_nquads)
}
inline std::string* Mutation::mutable_del_nquads() {
  std::string* _s = _internal_mutable_del_nquads();
  // @@protoc_insertion_point(field_mutable:api.Mutation.del_nquads)
  return _s;
}
inline const std::string& Mutation::_internal_del_nquads() const {
  return del_nquads_.Get();
}
inline void Mutation::_internal_set_del_nquads(const std::string& value) {
  
  del_nquads_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mutation::_internal_mutable_del_nquads() {
  
  return del_nquads_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mutation::release_del_nquads() {
  // @@protoc_insertion_point(field_release:api.Mutation.del_nquads)
  return del_nquads_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mutation::set_allocated_del_nquads(std::string* del_nquads) {
  if (del_nquads != nullptr) {
    
  } else {
    
  }
  del_nquads_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), del_nquads,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (del_nquads_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    del_nquads_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Mutation.del_nquads)
}

// repeated .api.NQuad set = 5;
inline int Mutation::_internal_set_size() const {
  return set_.size();
}
inline int Mutation::set_size() const {
  return _internal_set_size();
}
inline void Mutation::clear_set() {
  set_.Clear();
}
inline ::api::NQuad* Mutation::mutable_set(int index) {
  // @@protoc_insertion_point(field_mutable:api.Mutation.set)
  return set_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >*
Mutation::mutable_set() {
  // @@protoc_insertion_point(field_mutable_list:api.Mutation.set)
  return &set_;
}
inline const ::api::NQuad& Mutation::_internal_set(int index) const {
  return set_.Get(index);
}
inline const ::api::NQuad& Mutation::set(int index) const {
  // @@protoc_insertion_point(field_get:api.Mutation.set)
  return _internal_set(index);
}
inline ::api::NQuad* Mutation::_internal_add_set() {
  return set_.Add();
}
inline ::api::NQuad* Mutation::add_set() {
  ::api::NQuad* _add = _internal_add_set();
  // @@protoc_insertion_point(field_add:api.Mutation.set)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >&
Mutation::set() const {
  // @@protoc_insertion_point(field_list:api.Mutation.set)
  return set_;
}

// repeated .api.NQuad del = 6;
inline int Mutation::_internal_del_size() const {
  return del_.size();
}
inline int Mutation::del_size() const {
  return _internal_del_size();
}
inline void Mutation::clear_del() {
  del_.Clear();
}
inline ::api::NQuad* Mutation::mutable_del(int index) {
  // @@protoc_insertion_point(field_mutable:api.Mutation.del)
  return del_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >*
Mutation::mutable_del() {
  // @@protoc_insertion_point(field_mutable_list:api.Mutation.del)
  return &del_;
}
inline const ::api::NQuad& Mutation::_internal_del(int index) const {
  return del_.Get(index);
}
inline const ::api::NQuad& Mutation::del(int index) const {
  // @@protoc_insertion_point(field_get:api.Mutation.del)
  return _internal_del(index);
}
inline ::api::NQuad* Mutation::_internal_add_del() {
  return del_.Add();
}
inline ::api::NQuad* Mutation::add_del() {
  ::api::NQuad* _add = _internal_add_del();
  // @@protoc_insertion_point(field_add:api.Mutation.del)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::NQuad >&
Mutation::del() const {
  // @@protoc_insertion_point(field_list:api.Mutation.del)
  return del_;
}

// string cond = 9;
inline void Mutation::clear_cond() {
  cond_.ClearToEmpty();
}
inline const std::string& Mutation::cond() const {
  // @@protoc_insertion_point(field_get:api.Mutation.cond)
  return _internal_cond();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutation::set_cond(ArgT0&& arg0, ArgT... args) {
 
 cond_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Mutation.cond)
}
inline std::string* Mutation::mutable_cond() {
  std::string* _s = _internal_mutable_cond();
  // @@protoc_insertion_point(field_mutable:api.Mutation.cond)
  return _s;
}
inline const std::string& Mutation::_internal_cond() const {
  return cond_.Get();
}
inline void Mutation::_internal_set_cond(const std::string& value) {
  
  cond_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mutation::_internal_mutable_cond() {
  
  return cond_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mutation::release_cond() {
  // @@protoc_insertion_point(field_release:api.Mutation.cond)
  return cond_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mutation::set_allocated_cond(std::string* cond) {
  if (cond != nullptr) {
    
  } else {
    
  }
  cond_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cond,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cond_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cond_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Mutation.cond)
}

// bool commit_now = 14;
inline void Mutation::clear_commit_now() {
  commit_now_ = false;
}
inline bool Mutation::_internal_commit_now() const {
  return commit_now_;
}
inline bool Mutation::commit_now() const {
  // @@protoc_insertion_point(field_get:api.Mutation.commit_now)
  return _internal_commit_now();
}
inline void Mutation::_internal_set_commit_now(bool value) {
  
  commit_now_ = value;
}
inline void Mutation::set_commit_now(bool value) {
  _internal_set_commit_now(value);
  // @@protoc_insertion_point(field_set:api.Mutation.commit_now)
}

// -------------------------------------------------------------------

// Operation

// string schema = 1;
inline void Operation::clear_schema() {
  schema_.ClearToEmpty();
}
inline const std::string& Operation::schema() const {
  // @@protoc_insertion_point(field_get:api.Operation.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_schema(ArgT0&& arg0, ArgT... args) {
 
 schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Operation.schema)
}
inline std::string* Operation::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:api.Operation.schema)
  return _s;
}
inline const std::string& Operation::_internal_schema() const {
  return schema_.Get();
}
inline void Operation::_internal_set_schema(const std::string& value) {
  
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_schema() {
  
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Operation::release_schema() {
  // @@protoc_insertion_point(field_release:api.Operation.schema)
  return schema_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Operation::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Operation.schema)
}

// string drop_attr = 2;
inline void Operation::clear_drop_attr() {
  drop_attr_.ClearToEmpty();
}
inline const std::string& Operation::drop_attr() const {
  // @@protoc_insertion_point(field_get:api.Operation.drop_attr)
  return _internal_drop_attr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_drop_attr(ArgT0&& arg0, ArgT... args) {
 
 drop_attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Operation.drop_attr)
}
inline std::string* Operation::mutable_drop_attr() {
  std::string* _s = _internal_mutable_drop_attr();
  // @@protoc_insertion_point(field_mutable:api.Operation.drop_attr)
  return _s;
}
inline const std::string& Operation::_internal_drop_attr() const {
  return drop_attr_.Get();
}
inline void Operation::_internal_set_drop_attr(const std::string& value) {
  
  drop_attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_drop_attr() {
  
  return drop_attr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Operation::release_drop_attr() {
  // @@protoc_insertion_point(field_release:api.Operation.drop_attr)
  return drop_attr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Operation::set_allocated_drop_attr(std::string* drop_attr) {
  if (drop_attr != nullptr) {
    
  } else {
    
  }
  drop_attr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), drop_attr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (drop_attr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    drop_attr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Operation.drop_attr)
}

// bool drop_all = 3;
inline void Operation::clear_drop_all() {
  drop_all_ = false;
}
inline bool Operation::_internal_drop_all() const {
  return drop_all_;
}
inline bool Operation::drop_all() const {
  // @@protoc_insertion_point(field_get:api.Operation.drop_all)
  return _internal_drop_all();
}
inline void Operation::_internal_set_drop_all(bool value) {
  
  drop_all_ = value;
}
inline void Operation::set_drop_all(bool value) {
  _internal_set_drop_all(value);
  // @@protoc_insertion_point(field_set:api.Operation.drop_all)
}

// .api.Operation.DropOp drop_op = 4;
inline void Operation::clear_drop_op() {
  drop_op_ = 0;
}
inline ::api::Operation_DropOp Operation::_internal_drop_op() const {
  return static_cast< ::api::Operation_DropOp >(drop_op_);
}
inline ::api::Operation_DropOp Operation::drop_op() const {
  // @@protoc_insertion_point(field_get:api.Operation.drop_op)
  return _internal_drop_op();
}
inline void Operation::_internal_set_drop_op(::api::Operation_DropOp value) {
  
  drop_op_ = value;
}
inline void Operation::set_drop_op(::api::Operation_DropOp value) {
  _internal_set_drop_op(value);
  // @@protoc_insertion_point(field_set:api.Operation.drop_op)
}

// string drop_value = 5;
inline void Operation::clear_drop_value() {
  drop_value_.ClearToEmpty();
}
inline const std::string& Operation::drop_value() const {
  // @@protoc_insertion_point(field_get:api.Operation.drop_value)
  return _internal_drop_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_drop_value(ArgT0&& arg0, ArgT... args) {
 
 drop_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Operation.drop_value)
}
inline std::string* Operation::mutable_drop_value() {
  std::string* _s = _internal_mutable_drop_value();
  // @@protoc_insertion_point(field_mutable:api.Operation.drop_value)
  return _s;
}
inline const std::string& Operation::_internal_drop_value() const {
  return drop_value_.Get();
}
inline void Operation::_internal_set_drop_value(const std::string& value) {
  
  drop_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_drop_value() {
  
  return drop_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Operation::release_drop_value() {
  // @@protoc_insertion_point(field_release:api.Operation.drop_value)
  return drop_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Operation::set_allocated_drop_value(std::string* drop_value) {
  if (drop_value != nullptr) {
    
  } else {
    
  }
  drop_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), drop_value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (drop_value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    drop_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Operation.drop_value)
}

// bool run_in_background = 6;
inline void Operation::clear_run_in_background() {
  run_in_background_ = false;
}
inline bool Operation::_internal_run_in_background() const {
  return run_in_background_;
}
inline bool Operation::run_in_background() const {
  // @@protoc_insertion_point(field_get:api.Operation.run_in_background)
  return _internal_run_in_background();
}
inline void Operation::_internal_set_run_in_background(bool value) {
  
  run_in_background_ = value;
}
inline void Operation::set_run_in_background(bool value) {
  _internal_set_run_in_background(value);
  // @@protoc_insertion_point(field_set:api.Operation.run_in_background)
}

// -------------------------------------------------------------------

// Payload

// bytes Data = 1;
inline void Payload::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Payload::data() const {
  // @@protoc_insertion_point(field_get:api.Payload.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Payload.Data)
}
inline std::string* Payload::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:api.Payload.Data)
  return _s;
}
inline const std::string& Payload::_internal_data() const {
  return data_.Get();
}
inline void Payload::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Payload::release_data() {
  // @@protoc_insertion_point(field_release:api.Payload.Data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Payload::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Payload.Data)
}

// -------------------------------------------------------------------

// TxnContext

// uint64 start_ts = 1;
inline void TxnContext::clear_start_ts() {
  start_ts_ = uint64_t{0u};
}
inline uint64_t TxnContext::_internal_start_ts() const {
  return start_ts_;
}
inline uint64_t TxnContext::start_ts() const {
  // @@protoc_insertion_point(field_get:api.TxnContext.start_ts)
  return _internal_start_ts();
}
inline void TxnContext::_internal_set_start_ts(uint64_t value) {
  
  start_ts_ = value;
}
inline void TxnContext::set_start_ts(uint64_t value) {
  _internal_set_start_ts(value);
  // @@protoc_insertion_point(field_set:api.TxnContext.start_ts)
}

// uint64 commit_ts = 2;
inline void TxnContext::clear_commit_ts() {
  commit_ts_ = uint64_t{0u};
}
inline uint64_t TxnContext::_internal_commit_ts() const {
  return commit_ts_;
}
inline uint64_t TxnContext::commit_ts() const {
  // @@protoc_insertion_point(field_get:api.TxnContext.commit_ts)
  return _internal_commit_ts();
}
inline void TxnContext::_internal_set_commit_ts(uint64_t value) {
  
  commit_ts_ = value;
}
inline void TxnContext::set_commit_ts(uint64_t value) {
  _internal_set_commit_ts(value);
  // @@protoc_insertion_point(field_set:api.TxnContext.commit_ts)
}

// bool aborted = 3;
inline void TxnContext::clear_aborted() {
  aborted_ = false;
}
inline bool TxnContext::_internal_aborted() const {
  return aborted_;
}
inline bool TxnContext::aborted() const {
  // @@protoc_insertion_point(field_get:api.TxnContext.aborted)
  return _internal_aborted();
}
inline void TxnContext::_internal_set_aborted(bool value) {
  
  aborted_ = value;
}
inline void TxnContext::set_aborted(bool value) {
  _internal_set_aborted(value);
  // @@protoc_insertion_point(field_set:api.TxnContext.aborted)
}

// repeated string keys = 4;
inline int TxnContext::_internal_keys_size() const {
  return keys_.size();
}
inline int TxnContext::keys_size() const {
  return _internal_keys_size();
}
inline void TxnContext::clear_keys() {
  keys_.Clear();
}
inline std::string* TxnContext::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:api.TxnContext.keys)
  return _s;
}
inline const std::string& TxnContext::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& TxnContext::keys(int index) const {
  // @@protoc_insertion_point(field_get:api.TxnContext.keys)
  return _internal_keys(index);
}
inline std::string* TxnContext::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:api.TxnContext.keys)
  return keys_.Mutable(index);
}
inline void TxnContext::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api.TxnContext.keys)
}
inline void TxnContext::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api.TxnContext.keys)
}
inline void TxnContext::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api.TxnContext.keys)
}
inline void TxnContext::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api.TxnContext.keys)
}
inline std::string* TxnContext::_internal_add_keys() {
  return keys_.Add();
}
inline void TxnContext::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api.TxnContext.keys)
}
inline void TxnContext::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api.TxnContext.keys)
}
inline void TxnContext::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api.TxnContext.keys)
}
inline void TxnContext::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api.TxnContext.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxnContext::keys() const {
  // @@protoc_insertion_point(field_list:api.TxnContext.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxnContext::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:api.TxnContext.keys)
  return &keys_;
}

// repeated string preds = 5;
inline int TxnContext::_internal_preds_size() const {
  return preds_.size();
}
inline int TxnContext::preds_size() const {
  return _internal_preds_size();
}
inline void TxnContext::clear_preds() {
  preds_.Clear();
}
inline std::string* TxnContext::add_preds() {
  std::string* _s = _internal_add_preds();
  // @@protoc_insertion_point(field_add_mutable:api.TxnContext.preds)
  return _s;
}
inline const std::string& TxnContext::_internal_preds(int index) const {
  return preds_.Get(index);
}
inline const std::string& TxnContext::preds(int index) const {
  // @@protoc_insertion_point(field_get:api.TxnContext.preds)
  return _internal_preds(index);
}
inline std::string* TxnContext::mutable_preds(int index) {
  // @@protoc_insertion_point(field_mutable:api.TxnContext.preds)
  return preds_.Mutable(index);
}
inline void TxnContext::set_preds(int index, const std::string& value) {
  preds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api.TxnContext.preds)
}
inline void TxnContext::set_preds(int index, std::string&& value) {
  preds_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api.TxnContext.preds)
}
inline void TxnContext::set_preds(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api.TxnContext.preds)
}
inline void TxnContext::set_preds(int index, const char* value, size_t size) {
  preds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api.TxnContext.preds)
}
inline std::string* TxnContext::_internal_add_preds() {
  return preds_.Add();
}
inline void TxnContext::add_preds(const std::string& value) {
  preds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api.TxnContext.preds)
}
inline void TxnContext::add_preds(std::string&& value) {
  preds_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api.TxnContext.preds)
}
inline void TxnContext::add_preds(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api.TxnContext.preds)
}
inline void TxnContext::add_preds(const char* value, size_t size) {
  preds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api.TxnContext.preds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxnContext::preds() const {
  // @@protoc_insertion_point(field_list:api.TxnContext.preds)
  return preds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxnContext::mutable_preds() {
  // @@protoc_insertion_point(field_mutable_list:api.TxnContext.preds)
  return &preds_;
}

// string hash = 6;
inline void TxnContext::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& TxnContext::hash() const {
  // @@protoc_insertion_point(field_get:api.TxnContext.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnContext::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.TxnContext.hash)
}
inline std::string* TxnContext::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:api.TxnContext.hash)
  return _s;
}
inline const std::string& TxnContext::_internal_hash() const {
  return hash_.Get();
}
inline void TxnContext::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnContext::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnContext::release_hash() {
  // @@protoc_insertion_point(field_release:api.TxnContext.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxnContext::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.TxnContext.hash)
}

// -------------------------------------------------------------------

// Check

// -------------------------------------------------------------------

// Version

// string tag = 1;
inline void Version::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& Version::tag() const {
  // @@protoc_insertion_point(field_get:api.Version.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Version.tag)
}
inline std::string* Version::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:api.Version.tag)
  return _s;
}
inline const std::string& Version::_internal_tag() const {
  return tag_.Get();
}
inline void Version::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Version::release_tag() {
  // @@protoc_insertion_point(field_release:api.Version.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Version::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Version.tag)
}

// -------------------------------------------------------------------

// Latency

// uint64 parsing_ns = 1;
inline void Latency::clear_parsing_ns() {
  parsing_ns_ = uint64_t{0u};
}
inline uint64_t Latency::_internal_parsing_ns() const {
  return parsing_ns_;
}
inline uint64_t Latency::parsing_ns() const {
  // @@protoc_insertion_point(field_get:api.Latency.parsing_ns)
  return _internal_parsing_ns();
}
inline void Latency::_internal_set_parsing_ns(uint64_t value) {
  
  parsing_ns_ = value;
}
inline void Latency::set_parsing_ns(uint64_t value) {
  _internal_set_parsing_ns(value);
  // @@protoc_insertion_point(field_set:api.Latency.parsing_ns)
}

// uint64 processing_ns = 2;
inline void Latency::clear_processing_ns() {
  processing_ns_ = uint64_t{0u};
}
inline uint64_t Latency::_internal_processing_ns() const {
  return processing_ns_;
}
inline uint64_t Latency::processing_ns() const {
  // @@protoc_insertion_point(field_get:api.Latency.processing_ns)
  return _internal_processing_ns();
}
inline void Latency::_internal_set_processing_ns(uint64_t value) {
  
  processing_ns_ = value;
}
inline void Latency::set_processing_ns(uint64_t value) {
  _internal_set_processing_ns(value);
  // @@protoc_insertion_point(field_set:api.Latency.processing_ns)
}

// uint64 encoding_ns = 3;
inline void Latency::clear_encoding_ns() {
  encoding_ns_ = uint64_t{0u};
}
inline uint64_t Latency::_internal_encoding_ns() const {
  return encoding_ns_;
}
inline uint64_t Latency::encoding_ns() const {
  // @@protoc_insertion_point(field_get:api.Latency.encoding_ns)
  return _internal_encoding_ns();
}
inline void Latency::_internal_set_encoding_ns(uint64_t value) {
  
  encoding_ns_ = value;
}
inline void Latency::set_encoding_ns(uint64_t value) {
  _internal_set_encoding_ns(value);
  // @@protoc_insertion_point(field_set:api.Latency.encoding_ns)
}

// uint64 assign_timestamp_ns = 4;
inline void Latency::clear_assign_timestamp_ns() {
  assign_timestamp_ns_ = uint64_t{0u};
}
inline uint64_t Latency::_internal_assign_timestamp_ns() const {
  return assign_timestamp_ns_;
}
inline uint64_t Latency::assign_timestamp_ns() const {
  // @@protoc_insertion_point(field_get:api.Latency.assign_timestamp_ns)
  return _internal_assign_timestamp_ns();
}
inline void Latency::_internal_set_assign_timestamp_ns(uint64_t value) {
  
  assign_timestamp_ns_ = value;
}
inline void Latency::set_assign_timestamp_ns(uint64_t value) {
  _internal_set_assign_timestamp_ns(value);
  // @@protoc_insertion_point(field_set:api.Latency.assign_timestamp_ns)
}

// uint64 total_ns = 5;
inline void Latency::clear_total_ns() {
  total_ns_ = uint64_t{0u};
}
inline uint64_t Latency::_internal_total_ns() const {
  return total_ns_;
}
inline uint64_t Latency::total_ns() const {
  // @@protoc_insertion_point(field_get:api.Latency.total_ns)
  return _internal_total_ns();
}
inline void Latency::_internal_set_total_ns(uint64_t value) {
  
  total_ns_ = value;
}
inline void Latency::set_total_ns(uint64_t value) {
  _internal_set_total_ns(value);
  // @@protoc_insertion_point(field_set:api.Latency.total_ns)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metrics

// map<string, uint64> num_uids = 1;
inline int Metrics::_internal_num_uids_size() const {
  return num_uids_.size();
}
inline int Metrics::num_uids_size() const {
  return _internal_num_uids_size();
}
inline void Metrics::clear_num_uids() {
  num_uids_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
Metrics::_internal_num_uids() const {
  return num_uids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
Metrics::num_uids() const {
  // @@protoc_insertion_point(field_map:api.Metrics.num_uids)
  return _internal_num_uids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
Metrics::_internal_mutable_num_uids() {
  return num_uids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
Metrics::mutable_num_uids() {
  // @@protoc_insertion_point(field_mutable_map:api.Metrics.num_uids)
  return _internal_mutable_num_uids();
}

// -------------------------------------------------------------------

// NQuad

// string subject = 1;
inline void NQuad::clear_subject() {
  subject_.ClearToEmpty();
}
inline const std::string& NQuad::subject() const {
  // @@protoc_insertion_point(field_get:api.NQuad.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NQuad::set_subject(ArgT0&& arg0, ArgT... args) {
 
 subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.NQuad.subject)
}
inline std::string* NQuad::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:api.NQuad.subject)
  return _s;
}
inline const std::string& NQuad::_internal_subject() const {
  return subject_.Get();
}
inline void NQuad::_internal_set_subject(const std::string& value) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NQuad::_internal_mutable_subject() {
  
  return subject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NQuad::release_subject() {
  // @@protoc_insertion_point(field_release:api.NQuad.subject)
  return subject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NQuad::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  subject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subject,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subject_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.NQuad.subject)
}

// string predicate = 2;
inline void NQuad::clear_predicate() {
  predicate_.ClearToEmpty();
}
inline const std::string& NQuad::predicate() const {
  // @@protoc_insertion_point(field_get:api.NQuad.predicate)
  return _internal_predicate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NQuad::set_predicate(ArgT0&& arg0, ArgT... args) {
 
 predicate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.NQuad.predicate)
}
inline std::string* NQuad::mutable_predicate() {
  std::string* _s = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:api.NQuad.predicate)
  return _s;
}
inline const std::string& NQuad::_internal_predicate() const {
  return predicate_.Get();
}
inline void NQuad::_internal_set_predicate(const std::string& value) {
  
  predicate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NQuad::_internal_mutable_predicate() {
  
  return predicate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NQuad::release_predicate() {
  // @@protoc_insertion_point(field_release:api.NQuad.predicate)
  return predicate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NQuad::set_allocated_predicate(std::string* predicate) {
  if (predicate != nullptr) {
    
  } else {
    
  }
  predicate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predicate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (predicate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    predicate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.NQuad.predicate)
}

// string object_id = 3;
inline void NQuad::clear_object_id() {
  object_id_.ClearToEmpty();
}
inline const std::string& NQuad::object_id() const {
  // @@protoc_insertion_point(field_get:api.NQuad.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NQuad::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.NQuad.object_id)
}
inline std::string* NQuad::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:api.NQuad.object_id)
  return _s;
}
inline const std::string& NQuad::_internal_object_id() const {
  return object_id_.Get();
}
inline void NQuad::_internal_set_object_id(const std::string& value) {
  
  object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NQuad::_internal_mutable_object_id() {
  
  return object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NQuad::release_object_id() {
  // @@protoc_insertion_point(field_release:api.NQuad.object_id)
  return object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NQuad::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (object_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    object_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.NQuad.object_id)
}

// .api.Value object_value = 4;
inline bool NQuad::_internal_has_object_value() const {
  return this != internal_default_instance() && object_value_ != nullptr;
}
inline bool NQuad::has_object_value() const {
  return _internal_has_object_value();
}
inline void NQuad::clear_object_value() {
  if (GetArenaForAllocation() == nullptr && object_value_ != nullptr) {
    delete object_value_;
  }
  object_value_ = nullptr;
}
inline const ::api::Value& NQuad::_internal_object_value() const {
  const ::api::Value* p = object_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::Value&>(
      ::api::_Value_default_instance_);
}
inline const ::api::Value& NQuad::object_value() const {
  // @@protoc_insertion_point(field_get:api.NQuad.object_value)
  return _internal_object_value();
}
inline void NQuad::unsafe_arena_set_allocated_object_value(
    ::api::Value* object_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_value_);
  }
  object_value_ = object_value;
  if (object_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:api.NQuad.object_value)
}
inline ::api::Value* NQuad::release_object_value() {
  
  ::api::Value* temp = object_value_;
  object_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::api::Value* NQuad::unsafe_arena_release_object_value() {
  // @@protoc_insertion_point(field_release:api.NQuad.object_value)
  
  ::api::Value* temp = object_value_;
  object_value_ = nullptr;
  return temp;
}
inline ::api::Value* NQuad::_internal_mutable_object_value() {
  
  if (object_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::api::Value>(GetArenaForAllocation());
    object_value_ = p;
  }
  return object_value_;
}
inline ::api::Value* NQuad::mutable_object_value() {
  ::api::Value* _msg = _internal_mutable_object_value();
  // @@protoc_insertion_point(field_mutable:api.NQuad.object_value)
  return _msg;
}
inline void NQuad::set_allocated_object_value(::api::Value* object_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_value_;
  }
  if (object_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::api::Value>::GetOwningArena(object_value);
    if (message_arena != submessage_arena) {
      object_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_value, submessage_arena);
    }
    
  } else {
    
  }
  object_value_ = object_value;
  // @@protoc_insertion_point(field_set_allocated:api.NQuad.object_value)
}

// string lang = 6;
inline void NQuad::clear_lang() {
  lang_.ClearToEmpty();
}
inline const std::string& NQuad::lang() const {
  // @@protoc_insertion_point(field_get:api.NQuad.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NQuad::set_lang(ArgT0&& arg0, ArgT... args) {
 
 lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.NQuad.lang)
}
inline std::string* NQuad::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:api.NQuad.lang)
  return _s;
}
inline const std::string& NQuad::_internal_lang() const {
  return lang_.Get();
}
inline void NQuad::_internal_set_lang(const std::string& value) {
  
  lang_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NQuad::_internal_mutable_lang() {
  
  return lang_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NQuad::release_lang() {
  // @@protoc_insertion_point(field_release:api.NQuad.lang)
  return lang_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NQuad::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  lang_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lang,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lang_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lang_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.NQuad.lang)
}

// repeated .api.Facet facets = 7;
inline int NQuad::_internal_facets_size() const {
  return facets_.size();
}
inline int NQuad::facets_size() const {
  return _internal_facets_size();
}
inline void NQuad::clear_facets() {
  facets_.Clear();
}
inline ::api::Facet* NQuad::mutable_facets(int index) {
  // @@protoc_insertion_point(field_mutable:api.NQuad.facets)
  return facets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Facet >*
NQuad::mutable_facets() {
  // @@protoc_insertion_point(field_mutable_list:api.NQuad.facets)
  return &facets_;
}
inline const ::api::Facet& NQuad::_internal_facets(int index) const {
  return facets_.Get(index);
}
inline const ::api::Facet& NQuad::facets(int index) const {
  // @@protoc_insertion_point(field_get:api.NQuad.facets)
  return _internal_facets(index);
}
inline ::api::Facet* NQuad::_internal_add_facets() {
  return facets_.Add();
}
inline ::api::Facet* NQuad::add_facets() {
  ::api::Facet* _add = _internal_add_facets();
  // @@protoc_insertion_point(field_add:api.NQuad.facets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::api::Facet >&
NQuad::facets() const {
  // @@protoc_insertion_point(field_list:api.NQuad.facets)
  return facets_;
}

// uint64 namespace = 8;
inline void NQuad::clear_namespace_() {
  namespace__ = uint64_t{0u};
}
inline uint64_t NQuad::_internal_namespace_() const {
  return namespace__;
}
inline uint64_t NQuad::namespace_() const {
  // @@protoc_insertion_point(field_get:api.NQuad.namespace)
  return _internal_namespace_();
}
inline void NQuad::_internal_set_namespace_(uint64_t value) {
  
  namespace__ = value;
}
inline void NQuad::set_namespace_(uint64_t value) {
  _internal_set_namespace_(value);
  // @@protoc_insertion_point(field_set:api.NQuad.namespace)
}

// -------------------------------------------------------------------

// Value

// string default_val = 1;
inline bool Value::_internal_has_default_val() const {
  return val_case() == kDefaultVal;
}
inline bool Value::has_default_val() const {
  return _internal_has_default_val();
}
inline void Value::set_has_default_val() {
  _oneof_case_[0] = kDefaultVal;
}
inline void Value::clear_default_val() {
  if (_internal_has_default_val()) {
    val_.default_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::default_val() const {
  // @@protoc_insertion_point(field_get:api.Value.default_val)
  return _internal_default_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_default_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_default_val()) {
    clear_val();
    set_has_default_val();
    val_.default_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.default_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.default_val)
}
inline std::string* Value::mutable_default_val() {
  std::string* _s = _internal_mutable_default_val();
  // @@protoc_insertion_point(field_mutable:api.Value.default_val)
  return _s;
}
inline const std::string& Value::_internal_default_val() const {
  if (_internal_has_default_val()) {
    return val_.default_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_default_val(const std::string& value) {
  if (!_internal_has_default_val()) {
    clear_val();
    set_has_default_val();
    val_.default_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.default_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_default_val() {
  if (!_internal_has_default_val()) {
    clear_val();
    set_has_default_val();
    val_.default_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.default_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_default_val() {
  // @@protoc_insertion_point(field_release:api.Value.default_val)
  if (_internal_has_default_val()) {
    clear_has_val();
    return val_.default_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_default_val(std::string* default_val) {
  if (has_val()) {
    clear_val();
  }
  if (default_val != nullptr) {
    set_has_default_val();
    val_.default_val_.UnsafeSetDefault(default_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(default_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.default_val)
}

// bytes bytes_val = 2;
inline bool Value::_internal_has_bytes_val() const {
  return val_case() == kBytesVal;
}
inline bool Value::has_bytes_val() const {
  return _internal_has_bytes_val();
}
inline void Value::set_has_bytes_val() {
  _oneof_case_[0] = kBytesVal;
}
inline void Value::clear_bytes_val() {
  if (_internal_has_bytes_val()) {
    val_.bytes_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::bytes_val() const {
  // @@protoc_insertion_point(field_get:api.Value.bytes_val)
  return _internal_bytes_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_bytes_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytes_val()) {
    clear_val();
    set_has_bytes_val();
    val_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.bytes_val_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.bytes_val)
}
inline std::string* Value::mutable_bytes_val() {
  std::string* _s = _internal_mutable_bytes_val();
  // @@protoc_insertion_point(field_mutable:api.Value.bytes_val)
  return _s;
}
inline const std::string& Value::_internal_bytes_val() const {
  if (_internal_has_bytes_val()) {
    return val_.bytes_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_bytes_val(const std::string& value) {
  if (!_internal_has_bytes_val()) {
    clear_val();
    set_has_bytes_val();
    val_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.bytes_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_bytes_val() {
  if (!_internal_has_bytes_val()) {
    clear_val();
    set_has_bytes_val();
    val_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.bytes_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_bytes_val() {
  // @@protoc_insertion_point(field_release:api.Value.bytes_val)
  if (_internal_has_bytes_val()) {
    clear_has_val();
    return val_.bytes_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_bytes_val(std::string* bytes_val) {
  if (has_val()) {
    clear_val();
  }
  if (bytes_val != nullptr) {
    set_has_bytes_val();
    val_.bytes_val_.UnsafeSetDefault(bytes_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(bytes_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.bytes_val)
}

// int64 int_val = 3;
inline bool Value::_internal_has_int_val() const {
  return val_case() == kIntVal;
}
inline bool Value::has_int_val() const {
  return _internal_has_int_val();
}
inline void Value::set_has_int_val() {
  _oneof_case_[0] = kIntVal;
}
inline void Value::clear_int_val() {
  if (_internal_has_int_val()) {
    val_.int_val_ = int64_t{0};
    clear_has_val();
  }
}
inline int64_t Value::_internal_int_val() const {
  if (_internal_has_int_val()) {
    return val_.int_val_;
  }
  return int64_t{0};
}
inline void Value::_internal_set_int_val(int64_t value) {
  if (!_internal_has_int_val()) {
    clear_val();
    set_has_int_val();
  }
  val_.int_val_ = value;
}
inline int64_t Value::int_val() const {
  // @@protoc_insertion_point(field_get:api.Value.int_val)
  return _internal_int_val();
}
inline void Value::set_int_val(int64_t value) {
  _internal_set_int_val(value);
  // @@protoc_insertion_point(field_set:api.Value.int_val)
}

// bool bool_val = 4;
inline bool Value::_internal_has_bool_val() const {
  return val_case() == kBoolVal;
}
inline bool Value::has_bool_val() const {
  return _internal_has_bool_val();
}
inline void Value::set_has_bool_val() {
  _oneof_case_[0] = kBoolVal;
}
inline void Value::clear_bool_val() {
  if (_internal_has_bool_val()) {
    val_.bool_val_ = false;
    clear_has_val();
  }
}
inline bool Value::_internal_bool_val() const {
  if (_internal_has_bool_val()) {
    return val_.bool_val_;
  }
  return false;
}
inline void Value::_internal_set_bool_val(bool value) {
  if (!_internal_has_bool_val()) {
    clear_val();
    set_has_bool_val();
  }
  val_.bool_val_ = value;
}
inline bool Value::bool_val() const {
  // @@protoc_insertion_point(field_get:api.Value.bool_val)
  return _internal_bool_val();
}
inline void Value::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:api.Value.bool_val)
}

// string str_val = 5;
inline bool Value::_internal_has_str_val() const {
  return val_case() == kStrVal;
}
inline bool Value::has_str_val() const {
  return _internal_has_str_val();
}
inline void Value::set_has_str_val() {
  _oneof_case_[0] = kStrVal;
}
inline void Value::clear_str_val() {
  if (_internal_has_str_val()) {
    val_.str_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::str_val() const {
  // @@protoc_insertion_point(field_get:api.Value.str_val)
  return _internal_str_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_str_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_str_val()) {
    clear_val();
    set_has_str_val();
    val_.str_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.str_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.str_val)
}
inline std::string* Value::mutable_str_val() {
  std::string* _s = _internal_mutable_str_val();
  // @@protoc_insertion_point(field_mutable:api.Value.str_val)
  return _s;
}
inline const std::string& Value::_internal_str_val() const {
  if (_internal_has_str_val()) {
    return val_.str_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_str_val(const std::string& value) {
  if (!_internal_has_str_val()) {
    clear_val();
    set_has_str_val();
    val_.str_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.str_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_str_val() {
  if (!_internal_has_str_val()) {
    clear_val();
    set_has_str_val();
    val_.str_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.str_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_str_val() {
  // @@protoc_insertion_point(field_release:api.Value.str_val)
  if (_internal_has_str_val()) {
    clear_has_val();
    return val_.str_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_str_val(std::string* str_val) {
  if (has_val()) {
    clear_val();
  }
  if (str_val != nullptr) {
    set_has_str_val();
    val_.str_val_.UnsafeSetDefault(str_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(str_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.str_val)
}

// double double_val = 6;
inline bool Value::_internal_has_double_val() const {
  return val_case() == kDoubleVal;
}
inline bool Value::has_double_val() const {
  return _internal_has_double_val();
}
inline void Value::set_has_double_val() {
  _oneof_case_[0] = kDoubleVal;
}
inline void Value::clear_double_val() {
  if (_internal_has_double_val()) {
    val_.double_val_ = 0;
    clear_has_val();
  }
}
inline double Value::_internal_double_val() const {
  if (_internal_has_double_val()) {
    return val_.double_val_;
  }
  return 0;
}
inline void Value::_internal_set_double_val(double value) {
  if (!_internal_has_double_val()) {
    clear_val();
    set_has_double_val();
  }
  val_.double_val_ = value;
}
inline double Value::double_val() const {
  // @@protoc_insertion_point(field_get:api.Value.double_val)
  return _internal_double_val();
}
inline void Value::set_double_val(double value) {
  _internal_set_double_val(value);
  // @@protoc_insertion_point(field_set:api.Value.double_val)
}

// bytes geo_val = 7;
inline bool Value::_internal_has_geo_val() const {
  return val_case() == kGeoVal;
}
inline bool Value::has_geo_val() const {
  return _internal_has_geo_val();
}
inline void Value::set_has_geo_val() {
  _oneof_case_[0] = kGeoVal;
}
inline void Value::clear_geo_val() {
  if (_internal_has_geo_val()) {
    val_.geo_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::geo_val() const {
  // @@protoc_insertion_point(field_get:api.Value.geo_val)
  return _internal_geo_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_geo_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_geo_val()) {
    clear_val();
    set_has_geo_val();
    val_.geo_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.geo_val_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.geo_val)
}
inline std::string* Value::mutable_geo_val() {
  std::string* _s = _internal_mutable_geo_val();
  // @@protoc_insertion_point(field_mutable:api.Value.geo_val)
  return _s;
}
inline const std::string& Value::_internal_geo_val() const {
  if (_internal_has_geo_val()) {
    return val_.geo_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_geo_val(const std::string& value) {
  if (!_internal_has_geo_val()) {
    clear_val();
    set_has_geo_val();
    val_.geo_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.geo_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_geo_val() {
  if (!_internal_has_geo_val()) {
    clear_val();
    set_has_geo_val();
    val_.geo_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.geo_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_geo_val() {
  // @@protoc_insertion_point(field_release:api.Value.geo_val)
  if (_internal_has_geo_val()) {
    clear_has_val();
    return val_.geo_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_geo_val(std::string* geo_val) {
  if (has_val()) {
    clear_val();
  }
  if (geo_val != nullptr) {
    set_has_geo_val();
    val_.geo_val_.UnsafeSetDefault(geo_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(geo_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.geo_val)
}

// bytes date_val = 8;
inline bool Value::_internal_has_date_val() const {
  return val_case() == kDateVal;
}
inline bool Value::has_date_val() const {
  return _internal_has_date_val();
}
inline void Value::set_has_date_val() {
  _oneof_case_[0] = kDateVal;
}
inline void Value::clear_date_val() {
  if (_internal_has_date_val()) {
    val_.date_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::date_val() const {
  // @@protoc_insertion_point(field_get:api.Value.date_val)
  return _internal_date_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_date_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_date_val()) {
    clear_val();
    set_has_date_val();
    val_.date_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.date_val_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.date_val)
}
inline std::string* Value::mutable_date_val() {
  std::string* _s = _internal_mutable_date_val();
  // @@protoc_insertion_point(field_mutable:api.Value.date_val)
  return _s;
}
inline const std::string& Value::_internal_date_val() const {
  if (_internal_has_date_val()) {
    return val_.date_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_date_val(const std::string& value) {
  if (!_internal_has_date_val()) {
    clear_val();
    set_has_date_val();
    val_.date_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.date_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_date_val() {
  if (!_internal_has_date_val()) {
    clear_val();
    set_has_date_val();
    val_.date_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.date_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_date_val() {
  // @@protoc_insertion_point(field_release:api.Value.date_val)
  if (_internal_has_date_val()) {
    clear_has_val();
    return val_.date_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_date_val(std::string* date_val) {
  if (has_val()) {
    clear_val();
  }
  if (date_val != nullptr) {
    set_has_date_val();
    val_.date_val_.UnsafeSetDefault(date_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(date_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.date_val)
}

// bytes datetime_val = 9;
inline bool Value::_internal_has_datetime_val() const {
  return val_case() == kDatetimeVal;
}
inline bool Value::has_datetime_val() const {
  return _internal_has_datetime_val();
}
inline void Value::set_has_datetime_val() {
  _oneof_case_[0] = kDatetimeVal;
}
inline void Value::clear_datetime_val() {
  if (_internal_has_datetime_val()) {
    val_.datetime_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::datetime_val() const {
  // @@protoc_insertion_point(field_get:api.Value.datetime_val)
  return _internal_datetime_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_datetime_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_datetime_val()) {
    clear_val();
    set_has_datetime_val();
    val_.datetime_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.datetime_val_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.datetime_val)
}
inline std::string* Value::mutable_datetime_val() {
  std::string* _s = _internal_mutable_datetime_val();
  // @@protoc_insertion_point(field_mutable:api.Value.datetime_val)
  return _s;
}
inline const std::string& Value::_internal_datetime_val() const {
  if (_internal_has_datetime_val()) {
    return val_.datetime_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_datetime_val(const std::string& value) {
  if (!_internal_has_datetime_val()) {
    clear_val();
    set_has_datetime_val();
    val_.datetime_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.datetime_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_datetime_val() {
  if (!_internal_has_datetime_val()) {
    clear_val();
    set_has_datetime_val();
    val_.datetime_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.datetime_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_datetime_val() {
  // @@protoc_insertion_point(field_release:api.Value.datetime_val)
  if (_internal_has_datetime_val()) {
    clear_has_val();
    return val_.datetime_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_datetime_val(std::string* datetime_val) {
  if (has_val()) {
    clear_val();
  }
  if (datetime_val != nullptr) {
    set_has_datetime_val();
    val_.datetime_val_.UnsafeSetDefault(datetime_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(datetime_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.datetime_val)
}

// string password_val = 10;
inline bool Value::_internal_has_password_val() const {
  return val_case() == kPasswordVal;
}
inline bool Value::has_password_val() const {
  return _internal_has_password_val();
}
inline void Value::set_has_password_val() {
  _oneof_case_[0] = kPasswordVal;
}
inline void Value::clear_password_val() {
  if (_internal_has_password_val()) {
    val_.password_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_val();
  }
}
inline const std::string& Value::password_val() const {
  // @@protoc_insertion_point(field_get:api.Value.password_val)
  return _internal_password_val();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_password_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_password_val()) {
    clear_val();
    set_has_password_val();
    val_.password_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.password_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Value.password_val)
}
inline std::string* Value::mutable_password_val() {
  std::string* _s = _internal_mutable_password_val();
  // @@protoc_insertion_point(field_mutable:api.Value.password_val)
  return _s;
}
inline const std::string& Value::_internal_password_val() const {
  if (_internal_has_password_val()) {
    return val_.password_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_password_val(const std::string& value) {
  if (!_internal_has_password_val()) {
    clear_val();
    set_has_password_val();
    val_.password_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  val_.password_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_password_val() {
  if (!_internal_has_password_val()) {
    clear_val();
    set_has_password_val();
    val_.password_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return val_.password_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Value::release_password_val() {
  // @@protoc_insertion_point(field_release:api.Value.password_val)
  if (_internal_has_password_val()) {
    clear_has_val();
    return val_.password_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_password_val(std::string* password_val) {
  if (has_val()) {
    clear_val();
  }
  if (password_val != nullptr) {
    set_has_password_val();
    val_.password_val_.UnsafeSetDefault(password_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(password_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:api.Value.password_val)
}

// uint64 uid_val = 11;
inline bool Value::_internal_has_uid_val() const {
  return val_case() == kUidVal;
}
inline bool Value::has_uid_val() const {
  return _internal_has_uid_val();
}
inline void Value::set_has_uid_val() {
  _oneof_case_[0] = kUidVal;
}
inline void Value::clear_uid_val() {
  if (_internal_has_uid_val()) {
    val_.uid_val_ = uint64_t{0u};
    clear_has_val();
  }
}
inline uint64_t Value::_internal_uid_val() const {
  if (_internal_has_uid_val()) {
    return val_.uid_val_;
  }
  return uint64_t{0u};
}
inline void Value::_internal_set_uid_val(uint64_t value) {
  if (!_internal_has_uid_val()) {
    clear_val();
    set_has_uid_val();
  }
  val_.uid_val_ = value;
}
inline uint64_t Value::uid_val() const {
  // @@protoc_insertion_point(field_get:api.Value.uid_val)
  return _internal_uid_val();
}
inline void Value::set_uid_val(uint64_t value) {
  _internal_set_uid_val(value);
  // @@protoc_insertion_point(field_set:api.Value.uid_val)
}

inline bool Value::has_val() const {
  return val_case() != VAL_NOT_SET;
}
inline void Value::clear_has_val() {
  _oneof_case_[0] = VAL_NOT_SET;
}
inline Value::ValCase Value::val_case() const {
  return Value::ValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Facet

// string key = 1;
inline void Facet::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Facet::key() const {
  // @@protoc_insertion_point(field_get:api.Facet.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Facet::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Facet.key)
}
inline std::string* Facet::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:api.Facet.key)
  return _s;
}
inline const std::string& Facet::_internal_key() const {
  return key_.Get();
}
inline void Facet::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Facet::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Facet::release_key() {
  // @@protoc_insertion_point(field_release:api.Facet.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Facet::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Facet.key)
}

// bytes value = 2;
inline void Facet::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Facet::value() const {
  // @@protoc_insertion_point(field_get:api.Facet.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Facet::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Facet.value)
}
inline std::string* Facet::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:api.Facet.value)
  return _s;
}
inline const std::string& Facet::_internal_value() const {
  return value_.Get();
}
inline void Facet::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Facet::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Facet::release_value() {
  // @@protoc_insertion_point(field_release:api.Facet.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Facet::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Facet.value)
}

// .api.Facet.ValType val_type = 3;
inline void Facet::clear_val_type() {
  val_type_ = 0;
}
inline ::api::Facet_ValType Facet::_internal_val_type() const {
  return static_cast< ::api::Facet_ValType >(val_type_);
}
inline ::api::Facet_ValType Facet::val_type() const {
  // @@protoc_insertion_point(field_get:api.Facet.val_type)
  return _internal_val_type();
}
inline void Facet::_internal_set_val_type(::api::Facet_ValType value) {
  
  val_type_ = value;
}
inline void Facet::set_val_type(::api::Facet_ValType value) {
  _internal_set_val_type(value);
  // @@protoc_insertion_point(field_set:api.Facet.val_type)
}

// repeated string tokens = 4;
inline int Facet::_internal_tokens_size() const {
  return tokens_.size();
}
inline int Facet::tokens_size() const {
  return _internal_tokens_size();
}
inline void Facet::clear_tokens() {
  tokens_.Clear();
}
inline std::string* Facet::add_tokens() {
  std::string* _s = _internal_add_tokens();
  // @@protoc_insertion_point(field_add_mutable:api.Facet.tokens)
  return _s;
}
inline const std::string& Facet::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const std::string& Facet::tokens(int index) const {
  // @@protoc_insertion_point(field_get:api.Facet.tokens)
  return _internal_tokens(index);
}
inline std::string* Facet::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:api.Facet.tokens)
  return tokens_.Mutable(index);
}
inline void Facet::set_tokens(int index, const std::string& value) {
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:api.Facet.tokens)
}
inline void Facet::set_tokens(int index, std::string&& value) {
  tokens_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:api.Facet.tokens)
}
inline void Facet::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:api.Facet.tokens)
}
inline void Facet::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:api.Facet.tokens)
}
inline std::string* Facet::_internal_add_tokens() {
  return tokens_.Add();
}
inline void Facet::add_tokens(const std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:api.Facet.tokens)
}
inline void Facet::add_tokens(std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:api.Facet.tokens)
}
inline void Facet::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:api.Facet.tokens)
}
inline void Facet::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:api.Facet.tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Facet::tokens() const {
  // @@protoc_insertion_point(field_list:api.Facet.tokens)
  return tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Facet::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:api.Facet.tokens)
  return &tokens_;
}

// string alias = 5;
inline void Facet::clear_alias() {
  alias_.ClearToEmpty();
}
inline const std::string& Facet::alias() const {
  // @@protoc_insertion_point(field_get:api.Facet.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Facet::set_alias(ArgT0&& arg0, ArgT... args) {
 
 alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Facet.alias)
}
inline std::string* Facet::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:api.Facet.alias)
  return _s;
}
inline const std::string& Facet::_internal_alias() const {
  return alias_.Get();
}
inline void Facet::_internal_set_alias(const std::string& value) {
  
  alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Facet::_internal_mutable_alias() {
  
  return alias_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Facet::release_alias() {
  // @@protoc_insertion_point(field_release:api.Facet.alias)
  return alias_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Facet::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  alias_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alias,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alias_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Facet.alias)
}

// -------------------------------------------------------------------

// LoginRequest

// string userid = 1;
inline void LoginRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& LoginRequest::userid() const {
  // @@protoc_insertion_point(field_get:api.LoginRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.LoginRequest.userid)
}
inline std::string* LoginRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:api.LoginRequest.userid)
  return _s;
}
inline const std::string& LoginRequest::_internal_userid() const {
  return userid_.Get();
}
inline void LoginRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_userid() {
  // @@protoc_insertion_point(field_release:api.LoginRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.LoginRequest.userid)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:api.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:api.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:api.LoginRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.LoginRequest.password)
}

// string refresh_token = 3;
inline void LoginRequest::clear_refresh_token() {
  refresh_token_.ClearToEmpty();
}
inline const std::string& LoginRequest::refresh_token() const {
  // @@protoc_insertion_point(field_get:api.LoginRequest.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.LoginRequest.refresh_token)
}
inline std::string* LoginRequest::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:api.LoginRequest.refresh_token)
  return _s;
}
inline const std::string& LoginRequest::_internal_refresh_token() const {
  return refresh_token_.Get();
}
inline void LoginRequest::_internal_set_refresh_token(const std::string& value) {
  
  refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_refresh_token() {
  
  return refresh_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_refresh_token() {
  // @@protoc_insertion_point(field_release:api.LoginRequest.refresh_token)
  return refresh_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  refresh_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.LoginRequest.refresh_token)
}

// uint64 namespace = 4;
inline void LoginRequest::clear_namespace_() {
  namespace__ = uint64_t{0u};
}
inline uint64_t LoginRequest::_internal_namespace_() const {
  return namespace__;
}
inline uint64_t LoginRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:api.LoginRequest.namespace)
  return _internal_namespace_();
}
inline void LoginRequest::_internal_set_namespace_(uint64_t value) {
  
  namespace__ = value;
}
inline void LoginRequest::set_namespace_(uint64_t value) {
  _internal_set_namespace_(value);
  // @@protoc_insertion_point(field_set:api.LoginRequest.namespace)
}

// -------------------------------------------------------------------

// Jwt

// string access_jwt = 1;
inline void Jwt::clear_access_jwt() {
  access_jwt_.ClearToEmpty();
}
inline const std::string& Jwt::access_jwt() const {
  // @@protoc_insertion_point(field_get:api.Jwt.access_jwt)
  return _internal_access_jwt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Jwt::set_access_jwt(ArgT0&& arg0, ArgT... args) {
 
 access_jwt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Jwt.access_jwt)
}
inline std::string* Jwt::mutable_access_jwt() {
  std::string* _s = _internal_mutable_access_jwt();
  // @@protoc_insertion_point(field_mutable:api.Jwt.access_jwt)
  return _s;
}
inline const std::string& Jwt::_internal_access_jwt() const {
  return access_jwt_.Get();
}
inline void Jwt::_internal_set_access_jwt(const std::string& value) {
  
  access_jwt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Jwt::_internal_mutable_access_jwt() {
  
  return access_jwt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Jwt::release_access_jwt() {
  // @@protoc_insertion_point(field_release:api.Jwt.access_jwt)
  return access_jwt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Jwt::set_allocated_access_jwt(std::string* access_jwt) {
  if (access_jwt != nullptr) {
    
  } else {
    
  }
  access_jwt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_jwt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_jwt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_jwt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Jwt.access_jwt)
}

// string refresh_jwt = 2;
inline void Jwt::clear_refresh_jwt() {
  refresh_jwt_.ClearToEmpty();
}
inline const std::string& Jwt::refresh_jwt() const {
  // @@protoc_insertion_point(field_get:api.Jwt.refresh_jwt)
  return _internal_refresh_jwt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Jwt::set_refresh_jwt(ArgT0&& arg0, ArgT... args) {
 
 refresh_jwt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:api.Jwt.refresh_jwt)
}
inline std::string* Jwt::mutable_refresh_jwt() {
  std::string* _s = _internal_mutable_refresh_jwt();
  // @@protoc_insertion_point(field_mutable:api.Jwt.refresh_jwt)
  return _s;
}
inline const std::string& Jwt::_internal_refresh_jwt() const {
  return refresh_jwt_.Get();
}
inline void Jwt::_internal_set_refresh_jwt(const std::string& value) {
  
  refresh_jwt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Jwt::_internal_mutable_refresh_jwt() {
  
  return refresh_jwt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Jwt::release_refresh_jwt() {
  // @@protoc_insertion_point(field_release:api.Jwt.refresh_jwt)
  return refresh_jwt_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Jwt::set_allocated_refresh_jwt(std::string* refresh_jwt) {
  if (refresh_jwt != nullptr) {
    
  } else {
    
  }
  refresh_jwt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_jwt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_jwt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_jwt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:api.Jwt.refresh_jwt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::api::Request_RespFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::api::Request_RespFormat>() {
  return ::api::Request_RespFormat_descriptor();
}
template <> struct is_proto_enum< ::api::Operation_DropOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::api::Operation_DropOp>() {
  return ::api::Operation_DropOp_descriptor();
}
template <> struct is_proto_enum< ::api::Facet_ValType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::api::Facet_ValType>() {
  return ::api::Facet_ValType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_api_2eproto
